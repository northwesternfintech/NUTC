2023-11-17T22:45:37.707 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:113)
2023-11-17T22:45:37.818 -0600 [            ] [rabbitmq] INFO     - Declared queue: market_order (RabbitMQQueueManager.cpp:24)
2023-11-17T22:45:38.029 -0600 [            ] [client_spawning] INFO     - Spawning client: vEp1vc2eJWPZKg6vSsSV8WxtySD3 (spawning.cpp:55)
2023-11-17T22:45:38.030 -0600 [            ] [client_spawning] INFO     - Spawning client: tfUPq1NibqWniLN1tWV12AS4LbB2 (spawning.cpp:55)
2023-11-17T22:45:38.030 -0600 [            ] [client_spawning] INFO     - Spawning client: szcG2b0woZfWPl8k9Mqo9TrZcDi1 (spawning.cpp:55)
2023-11-17T22:45:38.031 -0600 [            ] [client_spawning] INFO     - Spawning client: sZ73R58EHaO7CaL5LsvPLy3UJiF2 (spawning.cpp:55)
2023-11-17T22:45:38.031 -0600 [            ] [client_spawning] INFO     - Spawning client: vzZV25SctsUZOFPpptE8XXYFP6h2 (spawning.cpp:55)
2023-11-17T22:45:38.032 -0600 [            ] [client_spawning] INFO     - Spawning client: u6R3HD2QSgDJYrVf4AnANI0TCd0W (spawning.cpp:55)
2023-11-17T22:45:38.032 -0600 [            ] [client_spawning] INFO     - Spawning client: sRITdbaxLkcbr7UqreIbkLnjGFd2 (spawning.cpp:55)
2023-11-17T22:45:38.033 -0600 [            ] [client_spawning] INFO     - Spawning client: pPOMVLN4clSRH1qYIBs0YzBwHSO2 (spawning.cpp:55)
2023-11-17T22:45:38.033 -0600 [            ] [client_spawning] INFO     - Spawning client: p4t6lk3N39f8kRFSo0vUbPsyb562 (spawning.cpp:55)
2023-11-17T22:45:38.034 -0600 [            ] [client_spawning] INFO     - Spawning client: nikola (spawning.cpp:55)
2023-11-17T22:45:38.034 -0600 [            ] [client_spawning] INFO     - Spawning client: m6lroXzPVoaFp1e6reu3JdQiH9T2 (spawning.cpp:55)
2023-11-17T22:45:38.035 -0600 [            ] [client_spawning] INFO     - Spawning client: ih4Zrbi50wOcIeH0X0ClJZFpxKO2 (spawning.cpp:55)
2023-11-17T22:45:38.036 -0600 [            ] [client_spawning] INFO     - Spawning client: fqU1tS3CJFaNU2S0Z3BcJ26SpJg1 (spawning.cpp:55)
2023-11-17T22:45:38.036 -0600 [            ] [client_spawning] INFO     - Spawning client: nZqpF2XwGaVCkSnBiIQ7Pc0N30h2 (spawning.cpp:55)
2023-11-17T22:45:38.037 -0600 [            ] [client_spawning] INFO     - Spawning client: dMjYuz2o5qNlgn6ChJqkh1EjO5y1 (spawning.cpp:55)
2023-11-17T22:45:38.037 -0600 [            ] [client_spawning] INFO     - Spawning client: dIRpDzNt5eSGRNA45PPHjWNkxm03 (spawning.cpp:55)
2023-11-17T22:45:38.038 -0600 [            ] [client_spawning] INFO     - Spawning client: d90YbO8g8yVd5l0IDJTwllRhKEw2 (spawning.cpp:55)
2023-11-17T22:45:38.039 -0600 [            ] [client_spawning] INFO     - Spawning client: z33nqAalRAMIxNc9WA6IofKPqxa2 (spawning.cpp:55)
2023-11-17T22:45:38.039 -0600 [            ] [client_spawning] INFO     - Spawning client: bxFOh8c6O0N8wUbwsWy8tjrSx6j2 (spawning.cpp:55)
2023-11-17T22:45:38.040 -0600 [            ] [client_spawning] INFO     - Spawning client: bAn9yQBbSQVyydg1spe0mOTSfQv1 (spawning.cpp:55)
2023-11-17T22:45:38.041 -0600 [            ] [client_spawning] INFO     - Spawning client: Xv6bghS9LUU4kgtVm0OgAde41bF2 (spawning.cpp:55)
2023-11-17T22:45:38.042 -0600 [            ] [client_spawning] INFO     - Spawning client: XjWMqsw9vNWhNmkl6Xpsk9CbeZq1 (spawning.cpp:55)
2023-11-17T22:45:38.042 -0600 [            ] [client_spawning] INFO     - Spawning client: Wz6CZ7hopkVNDFHBk4dwymKdtSn2 (spawning.cpp:55)
2023-11-17T22:45:38.043 -0600 [            ] [client_spawning] INFO     - Spawning client: Yey7UiMacOhZzF3qq026sLFSy4s2 (spawning.cpp:55)
2023-11-17T22:45:38.044 -0600 [            ] [client_spawning] INFO     - Spawning client: WMD3NPaAoETLALeg7IQuU0N2c1y1 (spawning.cpp:55)
2023-11-17T22:45:38.044 -0600 [            ] [client_spawning] INFO     - Spawning client: U584QP7Vu5XUnI5BhQbGy4RS7R63 (spawning.cpp:55)
2023-11-17T22:45:38.046 -0600 [            ] [client_spawning] INFO     - Spawning client: TO7X6y8YbReU0R6qBbP4gkH7JSo2 (spawning.cpp:55)
2023-11-17T22:45:38.047 -0600 [            ] [client_spawning] INFO     - Spawning client: pWE4sOp0PXTmd1SzTKv8KaVpzzJ3 (spawning.cpp:55)
2023-11-17T22:45:38.047 -0600 [            ] [client_spawning] INFO     - Spawning client: RVexkN2ooOfxsTfbMoFx77XJw0p2 (spawning.cpp:55)
2023-11-17T22:45:38.048 -0600 [            ] [client_spawning] INFO     - Spawning client: xomq0rmnRUSLKWpn3gNypD6gk4J2 (spawning.cpp:55)
2023-11-17T22:45:38.048 -0600 [            ] [client_spawning] INFO     - Spawning client: AeZQsRFrWha6oRniED8vuOGttIm2 (spawning.cpp:55)
2023-11-17T22:45:38.049 -0600 [            ] [client_spawning] INFO     - Spawning client: RQ00bLQRuQRvgeJGeyPXSaifoGn1 (spawning.cpp:55)
2023-11-17T22:45:38.053 -0600 [            ] [client_spawning] INFO     - Spawning client: nzx26FtbbMMalsfAzTRYchzCbvA2 (spawning.cpp:55)
2023-11-17T22:45:38.058 -0600 [            ] [client_spawning] INFO     - Spawning client: QLfQAi10ifTzrfIZsO1HiWwxS612 (spawning.cpp:55)
2023-11-17T22:45:38.071 -0600 [            ] [client_spawning] INFO     - Spawning client: RKHzlSYI63TEnYemNInQTRKRQIA2 (spawning.cpp:55)
2023-11-17T22:45:38.090 -0600 [            ] [client_spawning] INFO     - Spawning client: 1 (spawning.cpp:55)
2023-11-17T22:45:38.105 -0600 [            ] [client_spawning] INFO     - Spawning client: QtIt3aQJaibz8BJ5jhdeaHpysmo2 (spawning.cpp:55)
2023-11-17T22:45:38.110 -0600 [            ] [client_spawning] INFO     - Spawning client: Tlg8KURPpmOOU6rkWmP0iACZDSp1 (spawning.cpp:55)
2023-11-17T22:45:38.111 -0600 [            ] [client_spawning] INFO     - Spawning client: HPl7qB7JXVPr8whA5CdeHkiIJgy2 (spawning.cpp:55)
2023-11-17T22:45:38.116 -0600 [            ] [client_spawning] INFO     - Spawning client: Pk6FSS2V7KfSAnqWvVUdIAj2cab2 (spawning.cpp:55)
2023-11-17T22:45:38.122 -0600 [            ] [client_spawning] INFO     - Spawning client: vH0E1xHtYmTepnWNZnQwPCkqLFh1 (spawning.cpp:55)
2023-11-17T22:45:38.123 -0600 [            ] [client_spawning] INFO     - Spawning client: oa59DwAVcwUSwJfR2stT9CUbfz72 (spawning.cpp:55)
2023-11-17T22:45:38.124 -0600 [            ] [client_spawning] INFO     - Spawning client: Mz5Hp4w4kzkAutAt6haML1fNhfBv (spawning.cpp:55)
2023-11-17T22:45:38.125 -0600 [            ] [client_spawning] INFO     - Spawning client: SOExGKAMOATETxtUCPo48qPlFgh1 (spawning.cpp:55)
2023-11-17T22:45:38.127 -0600 [            ] [client_spawning] INFO     - Spawning client: DcYnNW4BbDZutN58w9IgZBbyKnY2 (spawning.cpp:55)
2023-11-17T22:45:38.132 -0600 [            ] [client_spawning] INFO     - Spawning client: LpUbgaQgmigjD7JfDt5VDIcGOvI3 (spawning.cpp:55)
2023-11-17T22:45:38.144 -0600 [            ] [client_spawning] INFO     - Spawning client: GzdWwQ2lqpVTcGXPBz1y6gISOBG2 (spawning.cpp:55)
2023-11-17T22:45:38.164 -0600 [            ] [client_spawning] INFO     - Spawning client: KksxAyfGzAS6rt7WAz7Vjs5Mz4g1 (spawning.cpp:55)
2023-11-17T22:45:38.175 -0600 [            ] [client_spawning] INFO     - Spawning client: 1CwzMEOkmycXyz7LYY2HsXtFH043 (spawning.cpp:55)
2023-11-17T22:45:38.247 -0600 [            ] [client_spawning] INFO     - Spawning client: Dk8MZi5waHdXwcCbeTQIFdS7Q242 (spawning.cpp:55)
2023-11-17T22:45:38.253 -0600 [            ] [client_spawning] INFO     - Spawning client: DUvYA4mK6BhdXL0zVUa4aXJMvJm1 (spawning.cpp:55)
2023-11-17T22:45:38.296 -0600 [            ] [client_spawning] INFO     - Spawning client: kvtrBumDkedmx1gFnM0KXVOh86D3 (spawning.cpp:55)
2023-11-17T22:45:38.303 -0600 [            ] [client_spawning] INFO     - Spawning client: dLqi77gh7iR8GrOvGASkHLKl6Zv1 (spawning.cpp:55)
2023-11-17T22:45:38.304 -0600 [            ] [client_spawning] INFO     - Spawning client: EOJWBQSXUDgKKAZJqB2x1npltgq1 (spawning.cpp:55)
2023-11-17T22:45:38.306 -0600 [            ] [client_spawning] INFO     - Spawning client: CjXvRz7veSWtiDXf7oeTXVdwchz2 (spawning.cpp:55)
2023-11-17T22:45:38.307 -0600 [            ] [client_spawning] INFO     - Spawning client: DjznltCPdUXEKWqmTzLIUyVnBO12 (spawning.cpp:55)
2023-11-17T22:45:38.310 -0600 [            ] [client_spawning] INFO     - Spawning client: 7NVpuKjZHZecKZDLSbisIhFf9i73 (spawning.cpp:55)
2023-11-17T22:45:38.330 -0600 [            ] [client_spawning] INFO     - Spawning client: CwwxcKXgT3dtGLMi9dwZnD7fqwg1 (spawning.cpp:55)
2023-11-17T22:45:38.375 -0600 [            ] [client_spawning] INFO     - Spawning client: BTq6jsS9lvNbmPINaCgLeMzTJyV2 (spawning.cpp:55)
2023-11-17T22:45:38.378 -0600 [            ] [client_spawning] INFO     - Spawning client: H1WNXBJu24U0sDsdDdcG6NSp7n82 (spawning.cpp:55)
2023-11-17T22:45:38.416 -0600 [            ] [client_spawning] INFO     - Spawning client: APxm07JJOIOEzJgGQio5xBevnb12 (spawning.cpp:55)
2023-11-17T22:45:38.422 -0600 [            ] [client_spawning] INFO     - Spawning client: 02KqrrLYSVgUGzIGN2H57LnmxeP2 (spawning.cpp:55)
2023-11-17T22:45:38.423 -0600 [            ] [client_spawning] INFO     - Spawning client: 5 (spawning.cpp:55)
2023-11-17T22:45:38.429 -0600 [            ] [client_spawning] INFO     - Spawning client: 123 (spawning.cpp:55)
2023-11-17T22:45:38.431 -0600 [            ] [client_spawning] INFO     - Spawning client: AIzaSyCo2l3x2DMhg5CaNy1Pyvknk_GK8v34iUc (spawning.cpp:55)
2023-11-17T22:45:38.433 -0600 [            ] [client_spawning] INFO     - Spawning client: 9VfgD1yx5aQ7XxUigQ5lflMkf9b2 (spawning.cpp:55)
2023-11-17T22:45:38.448 -0600 [            ] [client_spawning] INFO     - Spawning client: 4KwPAaSMcaUCyYEQVShsWb0J2wk2 (spawning.cpp:55)
2023-11-17T22:45:38.449 -0600 [            ] [client_spawning] INFO     - Spawning client: nsogzsFY6LVgnvC615TrbJ2XjXR2 (spawning.cpp:55)
2023-11-17T22:45:38.450 -0600 [            ] [client_spawning] INFO     - Spawning client: 4F0BgYAoEnX8A8mIriFNdUaoSXG2 (spawning.cpp:55)
2023-11-17T22:45:38.451 -0600 [            ] [client_spawning] INFO     - Spawning client: cWXl4LulGIPspjc9QZxVGXWST6S2 (spawning.cpp:55)
2023-11-17T22:45:38.452 -0600 [            ] [client_spawning] INFO     - Spawning client: 2EpG9YUMr5NtGPwgZCwFiTKpOVK2 (spawning.cpp:55)
2023-11-17T22:45:38.454 -0600 [            ] [client_spawning] INFO     - Spawning client: lYTpRGcLfJZGas4kyXc8DfpmJuz1 (spawning.cpp:55)
2023-11-17T22:45:38.455 -0600 [            ] [client_spawning] INFO     - Spawning client: 3orixu0bYOUWvL7WO283vfqu2233 (spawning.cpp:55)
2023-11-17T22:45:38.456 -0600 [            ] [client_spawning] INFO     - Spawning client: 33eij2KE0vVWqOx2buv1fYxwiB72 (spawning.cpp:55)
2023-11-17T22:45:38.459 -0600 [            ] [client_spawning] INFO     - Spawning client: xx (spawning.cpp:55)
2023-11-17T22:45:38.459 -0600 [            ] [client_spawning] INFO     - Spawning client: WEZuwN7bFhNqRTLTFR1UFsJ5eEe2 (spawning.cpp:55)
2023-11-17T22:45:38.460 -0600 [            ] [client_spawning] INFO     - Spawning client: MBjWWpExpOWPXNr3gLL9h7LgxDy2 (spawning.cpp:55)
2023-11-17T22:45:38.461 -0600 [            ] [client_spawning] INFO     - Spawning client: HQugRAugfsSAnGIftjywtoWeQ852 (spawning.cpp:55)
2023-11-17T22:45:38.462 -0600 [            ] [client_spawning] INFO     - Spawning client: 2cYNlCFxizV2eOV8jiOA2RxYybd2 (spawning.cpp:55)
2023-11-17T22:45:38.463 -0600 [            ] [client_spawning] INFO     - Spawning client: IDTH5BMlOrTq98bLxiVHnV6c0RM2 (spawning.cpp:55)
2023-11-17T22:45:38.464 -0600 [            ] [client_spawning] INFO     - Spawning client: 2wFmpzWttiTv8Nph9dJcBefnvY03 (spawning.cpp:55)
2023-11-17T22:45:38.465 -0600 [            ] [client_spawning] INFO     - Spawning client: T4fV0y361Tfi0ZaikLYRgTy6YUh1 (spawning.cpp:55)
2023-11-17T22:45:38.478 -0600 [            ] [client_spawning] INFO     - Spawning client: 6tMJ4MbOd6fTpUYDUGTiB2Ujnni2 (spawning.cpp:55)
2023-11-17T22:45:38.480 -0600 [            ] [client_spawning] INFO     - Spawning client: FosRw3EWkkbDKINqLjGc5LN2pQo2 (spawning.cpp:55)
2023-11-17T22:45:38.482 -0600 [            ] [client_spawning] INFO     - Spawning client: t6Svz58isiVhuarKJPg3Hjd3Eqq2 (spawning.cpp:55)
2023-11-17T22:45:38.483 -0600 [            ] [client_spawning] INFO     - Spawning client: WixRCfSehNO23MwGF7ZCy9ATnTC2 (spawning.cpp:55)
2023-11-17T22:45:38.491 -0600 [            ] [client_spawning] INFO     - Spawning client: 2jt06RLdlDUIg7xtTJEGEXlp3Pr2 (spawning.cpp:55)
2023-11-17T22:45:38.508 -0600 [            ] [client_spawning] INFO     - Spawning client: 6NfTjMvkhJSJJ3JFD1eGTYXTVSl2 (spawning.cpp:55)
2023-11-17T22:45:38.527 -0600 [            ] [client_spawning] INFO     - Spawning client: Cgr9vwsL8iUWI7xJ2dDYtwWzpmm1 (spawning.cpp:55)
2023-11-17T22:45:38.536 -0600 [            ] [client_spawning] INFO     - Spawning client: 48CRDUWi5USCEvKaR672OROuU5b2 (spawning.cpp:55)
2023-11-17T22:45:38.451 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.451 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.451 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.451 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID vEp1vc2eJWPZKg6vSsSV8WxtySD3 (main.cpp:96)
2023-11-17T22:45:38.571 -0600 [            ] [client_spawning] INFO     - Spawning client: GtPsjOf76iSCNKVkR1LgLmu9AoC3 (spawning.cpp:55)
2023-11-17T22:45:38.573 -0600 [            ] [client_spawning] INFO     - Spawning client: woeij (spawning.cpp:55)
2023-11-17T22:45:38.580 -0600 [            ] [client_spawning] INFO     - Spawning client: 1Pd1lJUMPURc0ezL393vWwRz9g32 (spawning.cpp:55)
2023-11-17T22:45:38.572 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.572 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.572 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.572 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID RQ00bLQRuQRvgeJGeyPXSaifoGn1 (main.cpp:96)
2023-11-17T22:45:38.505 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.505 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.505 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.505 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID AeZQsRFrWha6oRniED8vuOGttIm2 (main.cpp:96)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID szcG2b0woZfWPl8k9Mqo9TrZcDi1 (main.cpp:96)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID TO7X6y8YbReU0R6qBbP4gkH7JSo2 (main.cpp:96)
2023-11-17T22:45:38.505 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.506 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.506 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.506 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID dMjYuz2o5qNlgn6ChJqkh1EjO5y1 (main.cpp:96)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID KksxAyfGzAS6rt7WAz7Vjs5Mz4g1 (main.cpp:96)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.490 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID kvtrBumDkedmx1gFnM0KXVOh86D3 (main.cpp:96)
2023-11-17T22:45:38.581 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.581 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.581 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.581 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID RKHzlSYI63TEnYemNInQTRKRQIA2 (main.cpp:96)
2023-11-17T22:45:38.457 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.457 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.457 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.457 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID m6lroXzPVoaFp1e6reu3JdQiH9T2 (main.cpp:96)
2023-11-17T22:45:38.639 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:38.638 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.638 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.638 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.638 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID RVexkN2ooOfxsTfbMoFx77XJw0p2 (main.cpp:96)
2023-11-17T22:45:38.644 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.644 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.644 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.644 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID XjWMqsw9vNWhNmkl6Xpsk9CbeZq1 (main.cpp:96)
2023-11-17T22:45:38.916 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.126 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.131 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:38.860 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:38.860 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:38.860 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:38.860 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID tfUPq1NibqWniLN1tWV12AS4LbB2 (main.cpp:96)
2023-11-17T22:45:39.178 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.182 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.188 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.188 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.193 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.193 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.223 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.265 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.031 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.031 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.031 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.031 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID sRITdbaxLkcbr7UqreIbkLnjGFd2 (main.cpp:96)
2023-11-17T22:45:39.328 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.150 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.150 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.150 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.150 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 33eij2KE0vVWqOx2buv1fYxwiB72 (main.cpp:96)
2023-11-17T22:45:39.538 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.261 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.261 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.261 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.261 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID vH0E1xHtYmTepnWNZnQwPCkqLFh1 (main.cpp:96)
2023-11-17T22:45:39.185 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.185 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.185 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.185 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID Xv6bghS9LUU4kgtVm0OgAde41bF2 (main.cpp:96)
2023-11-17T22:45:39.135 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.135 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.135 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.135 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID cWXl4LulGIPspjc9QZxVGXWST6S2 (main.cpp:96)
2023-11-17T22:45:39.140 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.140 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.140 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.140 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID nikola (main.cpp:96)
2023-11-17T22:45:39.265 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.265 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.265 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.265 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID u6R3HD2QSgDJYrVf4AnANI0TCd0W (main.cpp:96)
2023-11-17T22:45:39.175 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.175 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.175 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.175 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID WMD3NPaAoETLALeg7IQuU0N2c1y1 (main.cpp:96)
2023-11-17T22:45:39.245 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.245 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.245 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.245 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID DcYnNW4BbDZutN58w9IgZBbyKnY2 (main.cpp:96)
2023-11-17T22:45:39.565 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.219 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.219 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.219 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.219 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID bAn9yQBbSQVyydg1spe0mOTSfQv1 (main.cpp:96)
2023-11-17T22:45:39.274 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.274 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.274 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.274 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID LpUbgaQgmigjD7JfDt5VDIcGOvI3 (main.cpp:96)
2023-11-17T22:45:39.220 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.220 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.220 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.220 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID SOExGKAMOATETxtUCPo48qPlFgh1 (main.cpp:96)
2023-11-17T22:45:39.675 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.297 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.297 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.297 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.297 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID ih4Zrbi50wOcIeH0X0ClJZFpxKO2 (main.cpp:96)
2023-11-17T22:45:39.267 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.267 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.267 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.267 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID pPOMVLN4clSRH1qYIBs0YzBwHSO2 (main.cpp:96)
2023-11-17T22:45:39.290 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.290 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.290 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.290 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID bxFOh8c6O0N8wUbwsWy8tjrSx6j2 (main.cpp:96)
2023-11-17T22:45:39.550 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.731 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.396 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.396 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.396 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.396 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID xomq0rmnRUSLKWpn3gNypD6gk4J2 (main.cpp:96)
2023-11-17T22:45:39.665 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.259 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.259 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.259 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.259 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID dIRpDzNt5eSGRNA45PPHjWNkxm03 (main.cpp:96)
2023-11-17T22:45:39.281 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.281 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.281 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.281 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID z33nqAalRAMIxNc9WA6IofKPqxa2 (main.cpp:96)
2023-11-17T22:45:39.457 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.457 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.457 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.457 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID nzx26FtbbMMalsfAzTRYchzCbvA2 (main.cpp:96)
2023-11-17T22:45:39.763 -0600 [            ] [firebase] INFO     - Running BestTrader (firebase.cpp:9)
2023-11-17T22:45:39.763 -0600 [            ] [firebase] INFO     - Description: This algorithm uses momentum strategies. (firebase.cpp:10)
2023-11-17T22:45:39.763 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:29:55.385Z (firebase.cpp:11)
2023-11-17T22:45:39.763 -0600 [            ] [firebase] INFO     - Algo id: -NgMqE0H09rJjL3j_c9J (firebase.cpp:13)
2023-11-17T22:45:39.551 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.551 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.551 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.551 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID sZ73R58EHaO7CaL5LsvPLy3UJiF2 (main.cpp:96)
2023-11-17T22:45:39.776 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.767 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.596 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.596 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.596 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.596 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID QtIt3aQJaibz8BJ5jhdeaHpysmo2 (main.cpp:96)
2023-11-17T22:45:39.396 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.396 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.396 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.396 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID Wz6CZ7hopkVNDFHBk4dwymKdtSn2 (main.cpp:96)
2023-11-17T22:45:39.621 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.535 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.535 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.535 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.535 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID Tlg8KURPpmOOU6rkWmP0iACZDSp1 (main.cpp:96)
2023-11-17T22:45:39.645 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.645 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.645 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.645 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 7NVpuKjZHZecKZDLSbisIhFf9i73 (main.cpp:96)
2023-11-17T22:45:39.583 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.583 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.583 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.583 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID EOJWBQSXUDgKKAZJqB2x1npltgq1 (main.cpp:96)
2023-11-17T22:45:39.458 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.458 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.458 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.458 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 1 (main.cpp:96)
2023-11-17T22:45:39.545 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.545 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.545 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.545 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID DjznltCPdUXEKWqmTzLIUyVnBO12 (main.cpp:96)
2023-11-17T22:45:39.447 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.447 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.447 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.447 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID d90YbO8g8yVd5l0IDJTwllRhKEw2 (main.cpp:96)
2023-11-17T22:45:39.433 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.433 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.433 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.433 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID vzZV25SctsUZOFPpptE8XXYFP6h2 (main.cpp:96)
2023-11-17T22:45:39.407 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.407 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.407 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.407 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID p4t6lk3N39f8kRFSo0vUbPsyb562 (main.cpp:96)
2023-11-17T22:45:39.653 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.653 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.653 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.653 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID CjXvRz7veSWtiDXf7oeTXVdwchz2 (main.cpp:96)
2023-11-17T22:45:39.619 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.619 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.619 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.619 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID IDTH5BMlOrTq98bLxiVHnV6c0RM2 (main.cpp:96)
2023-11-17T22:45:39.613 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.613 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.613 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.613 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 123 (main.cpp:96)
2023-11-17T22:45:39.462 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.462 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.462 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.462 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 5 (main.cpp:96)
2023-11-17T22:45:39.399 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.399 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.399 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.399 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID Yey7UiMacOhZzF3qq026sLFSy4s2 (main.cpp:96)
2023-11-17T22:45:39.636 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.882 -0600 [            ] [firebase] INFO     - Running long_short_MA_min_risk_2.0 (firebase.cpp:9)
2023-11-17T22:45:39.882 -0600 [            ] [firebase] INFO     - Description: # Simple trading algorithm that generates a buy signal if the short term (25 transactions) VWAP crosses above the 
# long term (200 transactions) and vice versa.
# Also minimizes the risk so that a flag to sell occurs when 2% of capital is lost from 
# when order was placed (firebase.cpp:10)
2023-11-17T22:45:39.882 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:58:44.298Z (firebase.cpp:11)
2023-11-17T22:45:39.882 -0600 [            ] [firebase] INFO     - Algo id: -NgMwtQlfuQcjLRYmoiF (firebase.cpp:13)
2023-11-17T22:45:39.458 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.458 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.458 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.458 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID APxm07JJOIOEzJgGQio5xBevnb12 (main.cpp:96)
2023-11-17T22:45:39.729 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.729 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.729 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.729 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID Pk6FSS2V7KfSAnqWvVUdIAj2cab2 (main.cpp:96)
2023-11-17T22:45:39.259 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.259 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.259 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.259 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID nZqpF2XwGaVCkSnBiIQ7Pc0N30h2 (main.cpp:96)
2023-11-17T22:45:39.488 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.488 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.488 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.488 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID U584QP7Vu5XUnI5BhQbGy4RS7R63 (main.cpp:96)
2023-11-17T22:45:39.551 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.551 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.551 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.551 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID H1WNXBJu24U0sDsdDdcG6NSp7n82 (main.cpp:96)
2023-11-17T22:45:39.573 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.598 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.598 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.598 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID oa59DwAVcwUSwJfR2stT9CUbfz72 (main.cpp:96)
2023-11-17T22:45:40.027 -0600 [            ] [firebase] INFO     - Running svm_stock_predictor (firebase.cpp:9)
2023-11-17T22:45:40.027 -0600 [            ] [firebase] INFO     - Description: I basically just use this application as a chance to learn - I created my first SVM and did my first big project on financial data. While there were some similarities to my past data projects, I had to learn many new topics to make this work.

This model takes in a csv of a stocks' close values for the past year. It trains an SVM based on the first 9 months of the dataset then validates it with the most recent 3 months. Future iterations of this model should integrate k-fold validation that still maintains the date-order of the data. This would limit overfitting that may be occurring in the current model.

The SVM takes in the past 5 days of close values as inputs and outputs the predicted close value for the next day. The model predicted the next days close price moderately accurate. However, the plot of the predictions suggested that the model's strength was predicting day to day differences. That is, the plot of the predictions matched the shape of the actual values, but  for some decently large intervals, the predicted values were strictly below the actual values. 

Based on this, the buy function is called by the model if up-to-date SVM growth prediction is more than 3%. (firebase.cpp:10)
2023-11-17T22:45:40.027 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:19:41.199Z (firebase.cpp:11)
2023-11-17T22:45:40.027 -0600 [            ] [firebase] INFO     - Algo id: -NgMe4IsVYrEz4J1aizM (firebase.cpp:13)
2023-11-17T22:45:40.026 -0600 [            ] [firebase] INFO     - Running Liquidity and History (firebase.cpp:9)
2023-11-17T22:45:40.026 -0600 [            ] [firebase] INFO     - Description: Look at the liquidity of a stock and its historical value to buy and sell stocks (firebase.cpp:10)
2023-11-17T22:45:40.026 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-09T20:08:53.473Z (firebase.cpp:11)
2023-11-17T22:45:40.026 -0600 [            ] [firebase] INFO     - Algo id: -NgL2baJlAa85ASARcOI (firebase.cpp:13)
2023-11-17T22:45:39.627 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.627 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.627 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.627 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID Dk8MZi5waHdXwcCbeTQIFdS7Q242 (main.cpp:96)
2023-11-17T22:45:39.578 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.578 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.578 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.578 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID fqU1tS3CJFaNU2S0Z3BcJ26SpJg1 (main.cpp:96)
2023-11-17T22:45:39.920 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.920 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.920 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.920 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID HPl7qB7JXVPr8whA5CdeHkiIJgy2 (main.cpp:96)
2023-11-17T22:45:40.105 -0600 [            ] [firebase] WARNING  - User kvtrBumDkedmx1gFnM0KXVOh86D3 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.105 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"kvtrBumDkedmx1gFnM0KXVOh86D3","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.120 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.130 -0600 [            ] [firebase] INFO     - Running Basic Moving Average Crossover (firebase.cpp:9)
2023-11-17T22:45:40.130 -0600 [            ] [firebase] INFO     - Description: Compares the average price of the last four trades to the last ten trades. Buys if the short period average is higher, sells if the short period average is lower. (firebase.cpp:10)
2023-11-17T22:45:40.130 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-09T23:50:29.822Z (firebase.cpp:11)
2023-11-17T22:45:40.130 -0600 [            ] [firebase] INFO     - Algo id: -NgLqL1Oiyt0iBeS7Era (firebase.cpp:13)
2023-11-17T22:45:40.134 -0600 [            ] [rabbitmq] INFO     - Received init message from client kvtrBumDkedmx1gFnM0KXVOh86D3 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.145 -0600 [            ] [rabbitmq] INFO     - Received init message from client vEp1vc2eJWPZKg6vSsSV8WxtySD3 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.139 -0600 [            ] [firebase] WARNING  - User vEp1vc2eJWPZKg6vSsSV8WxtySD3 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.139 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"vEp1vc2eJWPZKg6vSsSV8WxtySD3","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.146 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.157 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.157 -0600 [            ] [firebase] WARNING  - User dMjYuz2o5qNlgn6ChJqkh1EjO5y1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.157 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"dMjYuz2o5qNlgn6ChJqkh1EjO5y1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.156 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.724 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.725 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.725 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.725 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID pWE4sOp0PXTmd1SzTKv8KaVpzzJ3 (main.cpp:96)
2023-11-17T22:45:39.778 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.778 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.778 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.778 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID GzdWwQ2lqpVTcGXPBz1y6gISOBG2 (main.cpp:96)
2023-11-17T22:45:40.174 -0600 [            ] [rabbitmq] INFO     - Received init message from client dMjYuz2o5qNlgn6ChJqkh1EjO5y1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.164 -0600 [            ] [firebase] INFO     - Running test 2 (firebase.cpp:9)
2023-11-17T22:45:40.164 -0600 [            ] [firebase] INFO     - Description: test (firebase.cpp:10)
2023-11-17T22:45:40.164 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T02:01:10.890Z (firebase.cpp:11)
2023-11-17T22:45:40.164 -0600 [            ] [firebase] INFO     - Algo id: -NgMJFOFf_UfUd7jpBPC (firebase.cpp:13)
2023-11-17T22:45:40.150 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.759 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.759 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.759 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.759 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID BTq6jsS9lvNbmPINaCgLeMzTJyV2 (main.cpp:96)
2023-11-17T22:45:40.204 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.205 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.205 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.190 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.187 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.187 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:39.853 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.853 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.853 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.853 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID lYTpRGcLfJZGas4kyXc8DfpmJuz1 (main.cpp:96)
2023-11-17T22:45:40.221 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.225 -0600 [            ] [firebase] WARNING  - User szcG2b0woZfWPl8k9Mqo9TrZcDi1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.225 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"szcG2b0woZfWPl8k9Mqo9TrZcDi1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:39.912 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.912 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.912 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.912 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID dLqi77gh7iR8GrOvGASkHLKl6Zv1 (main.cpp:96)
2023-11-17T22:45:39.721 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.721 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.721 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.721 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID QLfQAi10ifTzrfIZsO1HiWwxS612 (main.cpp:96)
2023-11-17T22:45:39.956 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.956 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.956 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.956 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 02KqrrLYSVgUGzIGN2H57LnmxeP2 (main.cpp:96)
2023-11-17T22:45:40.229 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.237 -0600 [            ] [rabbitmq] INFO     - Received init message from client szcG2b0woZfWPl8k9Mqo9TrZcDi1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:39.867 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.867 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.867 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.867 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID HQugRAugfsSAnGIftjywtoWeQ852 (main.cpp:96)
2023-11-17T22:45:40.260 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.271 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.268 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.260 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.278 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.301 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.282 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.302 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.293 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.304 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.303 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.303 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.304 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.304 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.304 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.306 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.304 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.303 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.998 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.998 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.998 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.998 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID xx (main.cpp:96)
2023-11-17T22:45:40.010 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.010 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.010 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.010 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 2EpG9YUMr5NtGPwgZCwFiTKpOVK2 (main.cpp:96)
2023-11-17T22:45:40.341 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.343 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.351 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.304 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:39.900 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.900 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.900 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.900 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID AIzaSyCo2l3x2DMhg5CaNy1Pyvknk_GK8v34iUc (main.cpp:96)
2023-11-17T22:45:40.359 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.373 -0600 [            ] [firebase] WARNING  - User vH0E1xHtYmTepnWNZnQwPCkqLFh1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.373 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"vH0E1xHtYmTepnWNZnQwPCkqLFh1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.394 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.382 -0600 [            ] [rabbitmq] INFO     - Received init message from client vH0E1xHtYmTepnWNZnQwPCkqLFh1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:39.961 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:39.961 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:39.961 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:39.961 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 4KwPAaSMcaUCyYEQVShsWb0J2wk2 (main.cpp:96)
2023-11-17T22:45:40.344 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.403 -0600 [            ] [firebase] WARNING  - User AeZQsRFrWha6oRniED8vuOGttIm2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.403 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"AeZQsRFrWha6oRniED8vuOGttIm2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.376 -0600 [            ] [firebase] INFO     - Running ADX-based trading (firebase.cpp:9)
2023-11-17T22:45:40.376 -0600 [            ] [firebase] INFO     - Description: Compute ADX based on trades & orders. Map onto threshold prices for buying and selling and make orders accordingly.  (firebase.cpp:10)
2023-11-17T22:45:40.376 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T05:03:49.761Z (firebase.cpp:11)
2023-11-17T22:45:40.376 -0600 [            ] [firebase] INFO     - Algo id: -NgMy2Xu8zsmmhdpP9jd (firebase.cpp:13)
2023-11-17T22:45:40.043 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.043 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.043 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.043 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID WixRCfSehNO23MwGF7ZCy9ATnTC2 (main.cpp:96)
2023-11-17T22:45:40.044 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.044 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.044 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.044 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 4F0BgYAoEnX8A8mIriFNdUaoSXG2 (main.cpp:96)
2023-11-17T22:45:40.413 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.413 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.036 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.036 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.036 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.036 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID Cgr9vwsL8iUWI7xJ2dDYtwWzpmm1 (main.cpp:96)
2023-11-17T22:45:40.417 -0600 [            ] [rabbitmq] INFO     - Received init message from client AeZQsRFrWha6oRniED8vuOGttIm2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.160 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.183 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.183 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.183 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID T4fV0y361Tfi0ZaikLYRgTy6YUh1 (main.cpp:96)
2023-11-17T22:45:40.416 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"XjWMqsw9vNWhNmkl6Xpsk9CbeZq1","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:40.410 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.428 -0600 [            ] [rabbitmq] INFO     - Received init message from client XjWMqsw9vNWhNmkl6Xpsk9CbeZq1 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.445 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.445 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.086 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.086 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.086 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.086 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 9VfgD1yx5aQ7XxUigQ5lflMkf9b2 (main.cpp:96)
2023-11-17T22:45:40.423 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.169 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.169 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.169 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.169 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 2wFmpzWttiTv8Nph9dJcBefnvY03 (main.cpp:96)
2023-11-17T22:45:40.193 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.193 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.193 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.193 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 1Pd1lJUMPURc0ezL393vWwRz9g32 (main.cpp:96)
2023-11-17T22:45:40.080 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.080 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.080 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.080 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID Mz5Hp4w4kzkAutAt6haML1fNhfBv (main.cpp:96)
2023-11-17T22:45:40.158 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.159 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.159 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.159 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID WEZuwN7bFhNqRTLTFR1UFsJ5eEe2 (main.cpp:96)
2023-11-17T22:45:40.480 -0600 [            ] [rabbitmq] INFO     - Received init message from client TO7X6y8YbReU0R6qBbP4gkH7JSo2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.473 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.458 -0600 [            ] [firebase] WARNING  - User TO7X6y8YbReU0R6qBbP4gkH7JSo2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.466 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"TO7X6y8YbReU0R6qBbP4gkH7JSo2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.216 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.216 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.216 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.216 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID FosRw3EWkkbDKINqLjGc5LN2pQo2 (main.cpp:96)
2023-11-17T22:45:40.490 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.180 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.180 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.180 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.180 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID DUvYA4mK6BhdXL0zVUa4aXJMvJm1 (main.cpp:96)
2023-11-17T22:45:40.345 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.489 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.493 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.181 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.181 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.181 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.181 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID MBjWWpExpOWPXNr3gLL9h7LgxDy2 (main.cpp:96)
2023-11-17T22:45:40.081 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.081 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.081 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.081 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 3orixu0bYOUWvL7WO283vfqu2233 (main.cpp:96)
2023-11-17T22:45:40.446 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.495 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.518 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.512 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.528 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.549 -0600 [            ] [firebase] WARNING  - User SOExGKAMOATETxtUCPo48qPlFgh1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.549 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"SOExGKAMOATETxtUCPo48qPlFgh1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.561 -0600 [            ] [firebase] INFO     - Running Derivative Strategy (firebase.cpp:9)
2023-11-17T22:45:40.561 -0600 [            ] [firebase] INFO     - Description: Uses derivative to determine whether to buy or sell stock. (firebase.cpp:10)
2023-11-17T22:45:40.561 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-08T05:26:14.397Z (firebase.cpp:11)
2023-11-17T22:45:40.561 -0600 [            ] [firebase] INFO     - Algo id: -NgCk-xlZk0ltbp9vgmE (firebase.cpp:13)
2023-11-17T22:45:40.548 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.563 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.540 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.579 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.579 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.581 -0600 [            ] [rabbitmq] INFO     - Received init message from client SOExGKAMOATETxtUCPo48qPlFgh1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.581 -0600 [            ] [rabbitmq] INFO     - Received init message from client m6lroXzPVoaFp1e6reu3JdQiH9T2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.570 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"m6lroXzPVoaFp1e6reu3JdQiH9T2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:40.583 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"RKHzlSYI63TEnYemNInQTRKRQIA2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:40.597 -0600 [            ] [rabbitmq] INFO     - Received init message from client RKHzlSYI63TEnYemNInQTRKRQIA2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.575 -0600 [            ] [firebase] INFO     - Running LSTM neural network (firebase.cpp:9)
2023-11-17T22:45:40.575 -0600 [            ] [firebase] INFO     - Description: trains historical data... (firebase.cpp:10)
2023-11-17T22:45:40.575 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T01:45:37.936Z (firebase.cpp:11)
2023-11-17T22:45:40.576 -0600 [            ] [firebase] INFO     - Algo id: -NgMFghPe1cSbxrc-gpz (firebase.cpp:13)
2023-11-17T22:45:40.617 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.356 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.356 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.356 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.356 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID woeij (main.cpp:96)
2023-11-17T22:45:40.265 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.265 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.265 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.265 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID nsogzsFY6LVgnvC615TrbJ2XjXR2 (main.cpp:96)
2023-11-17T22:45:40.615 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.374 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.374 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.374 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.374 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 48CRDUWi5USCEvKaR672OROuU5b2 (main.cpp:96)
2023-11-17T22:45:40.617 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.627 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.634 -0600 [            ] [firebase] INFO     - Running FirstTest (firebase.cpp:9)
2023-11-17T22:45:40.634 -0600 [            ] [firebase] INFO     - Description: Test01 (firebase.cpp:10)
2023-11-17T22:45:40.634 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-09T19:02:19.910Z (firebase.cpp:11)
2023-11-17T22:45:40.634 -0600 [            ] [firebase] INFO     - Algo id: -NgKoMZYvgkYGsXPuXBF (firebase.cpp:13)
2023-11-17T22:45:40.636 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.638 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.639 -0600 [            ] [firebase] INFO     - Running test 1 (firebase.cpp:9)
2023-11-17T22:45:40.639 -0600 [            ] [firebase] INFO     - Description: my first test (firebase.cpp:10)
2023-11-17T22:45:40.639 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-09T18:31:17.714Z (firebase.cpp:11)
2023-11-17T22:45:40.639 -0600 [            ] [firebase] INFO     - Algo id: -NgKhGxMVXvMoEihHFIW (firebase.cpp:13)
2023-11-17T22:45:40.636 -0600 [            ] [firebase] WARNING  - User xomq0rmnRUSLKWpn3gNypD6gk4J2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.636 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"xomq0rmnRUSLKWpn3gNypD6gk4J2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.628 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.643 -0600 [            ] [rabbitmq] INFO     - Received init message from client xomq0rmnRUSLKWpn3gNypD6gk4J2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.648 -0600 [            ] [rabbitmq] INFO     - Received init message from client RQ00bLQRuQRvgeJGeyPXSaifoGn1 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.644 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"RQ00bLQRuQRvgeJGeyPXSaifoGn1","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:40.264 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.264 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.264 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.264 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 2cYNlCFxizV2eOV8jiOA2RxYybd2 (main.cpp:96)
2023-11-17T22:45:40.621 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.658 -0600 [            ] [firebase] INFO     - Running Bill Zhu; VWAP/Price Algo (firebase.cpp:9)
2023-11-17T22:45:40.658 -0600 [            ] [firebase] INFO     - Description: Estimate market entry points using VWAP and derivative trends. (firebase.cpp:10)
2023-11-17T22:45:40.658 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T03:25:20.870Z (firebase.cpp:11)
2023-11-17T22:45:40.658 -0600 [            ] [firebase] INFO     - Algo id: -NgMbWMoMJ_ck_l5w95M (firebase.cpp:13)
2023-11-17T22:45:40.280 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.280 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.280 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.280 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 1CwzMEOkmycXyz7LYY2HsXtFH043 (main.cpp:96)
2023-11-17T22:45:40.625 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.425 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.425 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.425 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.425 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 2jt06RLdlDUIg7xtTJEGEXlp3Pr2 (main.cpp:96)
2023-11-17T22:45:40.684 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.684 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.721 -0600 [            ] [rabbitmq] INFO     - Received init message from client pPOMVLN4clSRH1qYIBs0YzBwHSO2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.717 -0600 [            ] [firebase] WARNING  - User pPOMVLN4clSRH1qYIBs0YzBwHSO2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.717 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"pPOMVLN4clSRH1qYIBs0YzBwHSO2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.486 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.486 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.486 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.486 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 6NfTjMvkhJSJJ3JFD1eGTYXTVSl2 (main.cpp:96)
2023-11-17T22:45:40.727 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.746 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.746 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.746 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.477 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.477 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.477 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.477 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID CwwxcKXgT3dtGLMi9dwZnD7fqwg1 (main.cpp:96)
2023-11-17T22:45:40.713 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.618 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.618 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.618 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.618 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID 6tMJ4MbOd6fTpUYDUGTiB2Ujnni2 (main.cpp:96)
2023-11-17T22:45:40.819 -0600 [            ] [rabbitmq] INFO     - Received init message from client RVexkN2ooOfxsTfbMoFx77XJw0p2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.816 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"RVexkN2ooOfxsTfbMoFx77XJw0p2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:40.824 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"KksxAyfGzAS6rt7WAz7Vjs5Mz4g1","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:40.828 -0600 [            ] [rabbitmq] INFO     - Received init message from client KksxAyfGzAS6rt7WAz7Vjs5Mz4g1 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.871 -0600 [            ] [firebase] WARNING  - User d90YbO8g8yVd5l0IDJTwllRhKEw2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.871 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"d90YbO8g8yVd5l0IDJTwllRhKEw2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.874 -0600 [            ] [rabbitmq] INFO     - Received init message from client d90YbO8g8yVd5l0IDJTwllRhKEw2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.876 -0600 [            ] [firebase] WARNING  - User nZqpF2XwGaVCkSnBiIQ7Pc0N30h2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.876 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"nZqpF2XwGaVCkSnBiIQ7Pc0N30h2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.860 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.860 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.883 -0600 [            ] [rabbitmq] INFO     - Received init message from client nZqpF2XwGaVCkSnBiIQ7Pc0N30h2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.886 -0600 [            ] [rabbitmq] INFO     - Received init message from client Pk6FSS2V7KfSAnqWvVUdIAj2cab2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.889 -0600 [            ] [firebase] WARNING  - User EOJWBQSXUDgKKAZJqB2x1npltgq1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.889 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"EOJWBQSXUDgKKAZJqB2x1npltgq1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.892 -0600 [            ] [rabbitmq] INFO     - Received init message from client EOJWBQSXUDgKKAZJqB2x1npltgq1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.895 -0600 [            ] [firebase] INFO     - Running DiamondHands (firebase.cpp:9)
2023-11-17T22:45:40.895 -0600 [            ] [firebase] INFO     - Description: JUST BUY DONT SELL (firebase.cpp:10)
2023-11-17T22:45:40.895 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T03:52:36.741Z (firebase.cpp:11)
2023-11-17T22:45:40.895 -0600 [            ] [firebase] INFO     - Algo id: -NgMhl-jKVTPxTi3UObE (firebase.cpp:13)
2023-11-17T22:45:40.900 -0600 [            ] [firebase] WARNING  - User bAn9yQBbSQVyydg1spe0mOTSfQv1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.900 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"bAn9yQBbSQVyydg1spe0mOTSfQv1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.902 -0600 [            ] [rabbitmq] INFO     - Received init message from client bAn9yQBbSQVyydg1spe0mOTSfQv1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.902 -0600 [            ] [rabbitmq] INFO     - Received init message from client nzx26FtbbMMalsfAzTRYchzCbvA2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.911 -0600 [            ] [firebase] WARNING  - User fqU1tS3CJFaNU2S0Z3BcJ26SpJg1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.911 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"fqU1tS3CJFaNU2S0Z3BcJ26SpJg1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.914 -0600 [            ] [rabbitmq] INFO     - Received init message from client fqU1tS3CJFaNU2S0Z3BcJ26SpJg1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.917 -0600 [            ] [rabbitmq] INFO     - Received init message from client DjznltCPdUXEKWqmTzLIUyVnBO12 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.900 -0600 [            ] [firebase] WARNING  - User nzx26FtbbMMalsfAzTRYchzCbvA2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.900 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"nzx26FtbbMMalsfAzTRYchzCbvA2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.884 -0600 [            ] [firebase] WARNING  - User Pk6FSS2V7KfSAnqWvVUdIAj2cab2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.884 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"Pk6FSS2V7KfSAnqWvVUdIAj2cab2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.915 -0600 [            ] [firebase] WARNING  - User DjznltCPdUXEKWqmTzLIUyVnBO12 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.915 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"DjznltCPdUXEKWqmTzLIUyVnBO12","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.890 -0600 [            ] [firebase] INFO     - Running RTW3_DavidWong (firebase.cpp:9)
2023-11-17T22:45:40.890 -0600 [            ] [firebase] INFO     - Description: This idea is very simple. I will buy what other people value more and sell what they don't value as much. I will base what they value on the average price in the recent past compared to the long-term past. I only care about "real" prices so that means I only care about completed trades in my inferences.

As trades come in, if the trading price of completed trades averages higher in the short term more than it does in the long term, we BUY. We will buy if the average price proportional to the quantity sold is greater and if the average price overall is greater. Then, if it dips, then we will sell according to similar conditions. Threading is used to prevent changes until we have officially bought or sold. Preferably, I would be able to pull trades after a certain period of time, but we can't so I am running a risk of over buying or selling here. If I had more time and had the ability to test this, I would have fixed this.  (firebase.cpp:10)
2023-11-17T22:45:40.890 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-09T05:09:12.315Z (firebase.cpp:11)
2023-11-17T22:45:40.890 -0600 [            ] [firebase] INFO     - Algo id: -NgHpfhPvj2hyMFHY72C (firebase.cpp:13)
2023-11-17T22:45:40.925 -0600 [            ] [firebase] WARNING  - User APxm07JJOIOEzJgGQio5xBevnb12 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.928 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"APxm07JJOIOEzJgGQio5xBevnb12","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.933 -0600 [            ] [rabbitmq] INFO     - Received init message from client APxm07JJOIOEzJgGQio5xBevnb12 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.965 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.965 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:40.966 -0600 [            ] [firebase] INFO     - Running WD_Book_Depth_3 (firebase.cpp:9)
2023-11-17T22:45:40.966 -0600 [            ] [firebase] INFO     - Description: This algorithm trades based on the order book imbalance of the shares. The basic premise is that it buys when there is a high volume of bids on the book close to the current price and it sells when there is a high volume of asks close to the current price.

If the average price to acquire a full allocation of the asset (33,000 USD at the start) is less than the average of the prices to sell 5 times that amount and buy 5 times that amount, then it buys. If it can sell for more than that average, it sells (assuming we are holding the asset).

To implement this, the Strategy class contains an Orderbook class for each of the 3 tickers. That OrderBook class maintains a full order book for each ticker. It also contains methods to evaluate the OrderBook depth.

In order to maintain the full order book, the OrderBook class objects cache trade messages and match them with book updates to determine the sign of the updates (if there is a matching trade, that sign is negative). Additionally, there is a separate thread that goes back through and assumes that updates left unmatched must have a positive sign and updates the book accordingly. 3 seconds is set as the max difference between a trade message and a sell message.

The rationale for picking this strategy is that since orders cannot be canceled in this simulation, there will be significant resistance to price movement by a lot of orders.
 (firebase.cpp:10)
2023-11-17T22:45:40.966 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:43:48.120Z (firebase.cpp:11)
2023-11-17T22:45:40.966 -0600 [            ] [firebase] INFO     - Algo id: -NgMtTnji4W6Vlh2G7X6 (firebase.cpp:13)
2023-11-17T22:45:40.976 -0600 [            ] [rabbitmq] INFO     - Received init message from client p4t6lk3N39f8kRFSo0vUbPsyb562 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.581 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.581 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.581 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.581 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID t6Svz58isiVhuarKJPg3Hjd3Eqq2 (main.cpp:96)
2023-11-17T22:45:40.644 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:40.970 -0600 [            ] [firebase] WARNING  - User p4t6lk3N39f8kRFSo0vUbPsyb562 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.970 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"p4t6lk3N39f8kRFSo0vUbPsyb562","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.985 -0600 [            ] [firebase] WARNING  - User LpUbgaQgmigjD7JfDt5VDIcGOvI3 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:40.985 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"LpUbgaQgmigjD7JfDt5VDIcGOvI3","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.988 -0600 [            ] [rabbitmq] INFO     - Received init message from client LpUbgaQgmigjD7JfDt5VDIcGOvI3 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.023 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.023 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.024 -0600 [            ] [firebase] WARNING  - User cWXl4LulGIPspjc9QZxVGXWST6S2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.024 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"cWXl4LulGIPspjc9QZxVGXWST6S2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.026 -0600 [            ] [rabbitmq] INFO     - Received init message from client cWXl4LulGIPspjc9QZxVGXWST6S2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:40.997 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:41.028 -0600 [            ] [firebase] INFO     - Running Final (firebase.cpp:9)
2023-11-17T22:45:41.028 -0600 [            ] [firebase] INFO     - Description: Goal is to improve upon competing bid and ask prices by a penny so that trades are always executed through my bot first. Made sure orders are only placed if the last price executed on is not the best bid or ask price, to prevent it trading against itself. Additional orders are layered outside the best bid and ask to intercept large orders that may come in and profit off of larger spreads. (firebase.cpp:10)
2023-11-17T22:45:41.028 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T01:12:32.557Z (firebase.cpp:11)
2023-11-17T22:45:41.028 -0600 [            ] [firebase] INFO     - Algo id: -NgM86lB-cypKd8uiT-w (firebase.cpp:13)
2023-11-17T22:45:41.043 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.043 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.042 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.042 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.042 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"pWE4sOp0PXTmd1SzTKv8KaVpzzJ3","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.045 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.045 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.046 -0600 [            ] [firebase] WARNING  - User Tlg8KURPpmOOU6rkWmP0iACZDSp1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.046 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"Tlg8KURPpmOOU6rkWmP0iACZDSp1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.057 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"tfUPq1NibqWniLN1tWV12AS4LbB2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] WARNING  - User H1WNXBJu24U0sDsdDdcG6NSp7n82 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.051 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"H1WNXBJu24U0sDsdDdcG6NSp7n82","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.058 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"DcYnNW4BbDZutN58w9IgZBbyKnY2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] INFO     - Running Test 2 (firebase.cpp:9)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] INFO     - Description: testing (firebase.cpp:10)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-07T18:55:11.763Z (firebase.cpp:11)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] INFO     - Algo id: -NgAUZgrGc6c_55yAJcs (firebase.cpp:13)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] INFO     - Running OB Imbalance and Volatility Strategy - WORKING (firebase.cpp:9)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] INFO     - Description: The strategy monitors the top tiers of the order book. When updates occur, it calculates the imbalance and determines whether to initiate a trade. If a decision to trade is made, be it a BUY or SELL, the base order size, derived from our risk-tolerant capital, is adjusted based on volatility. Orders are placed with a safeguard mechanism: if they don't execute successfully, fallback approaches like placing a limit order, retrying after an interval, or decreasing the order size are employed. Additionally, a stop-loss mechanism activates if a loss exceeds a predefined threshold. (firebase.cpp:10)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-08T19:04:40.694Z (firebase.cpp:11)
2023-11-17T22:45:41.051 -0600 [            ] [firebase] INFO     - Algo id: -NgFfHdRInLahocbQrOR (firebase.cpp:13)
2023-11-17T22:45:41.046 -0600 [            ] [firebase] WARNING  - User IDTH5BMlOrTq98bLxiVHnV6c0RM2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.047 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"IDTH5BMlOrTq98bLxiVHnV6c0RM2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.046 -0600 [            ] [firebase] WARNING  - User sZ73R58EHaO7CaL5LsvPLy3UJiF2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.046 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"sZ73R58EHaO7CaL5LsvPLy3UJiF2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.045 -0600 [            ] [rabbitmq] INFO     - Received init message from client pWE4sOp0PXTmd1SzTKv8KaVpzzJ3 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.049 -0600 [            ] [rabbitmq] INFO     - Received init message from client sZ73R58EHaO7CaL5LsvPLy3UJiF2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.049 -0600 [            ] [rabbitmq] INFO     - Received init message from client CjXvRz7veSWtiDXf7oeTXVdwchz2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.049 -0600 [            ] [rabbitmq] INFO     - Received init message from client IDTH5BMlOrTq98bLxiVHnV6c0RM2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.049 -0600 [            ] [rabbitmq] INFO     - Received init message from client Tlg8KURPpmOOU6rkWmP0iACZDSp1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.049 -0600 [            ] [rabbitmq] INFO     - Received init message from client BTq6jsS9lvNbmPINaCgLeMzTJyV2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.057 -0600 [            ] [rabbitmq] INFO     - Received init message from client H1WNXBJu24U0sDsdDdcG6NSp7n82 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.047 -0600 [            ] [firebase] WARNING  - User BTq6jsS9lvNbmPINaCgLeMzTJyV2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.047 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"BTq6jsS9lvNbmPINaCgLeMzTJyV2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.063 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.063 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.046 -0600 [            ] [firebase] WARNING  - User CjXvRz7veSWtiDXf7oeTXVdwchz2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.046 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"CjXvRz7veSWtiDXf7oeTXVdwchz2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.063 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.063 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.063 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.063 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.068 -0600 [            ] [firebase] INFO     - Running movingavg (firebase.cpp:9)
2023-11-17T22:45:41.068 -0600 [            ] [firebase] INFO     - Description: Used the moving average strategy to determine market entry side, price, and quantity (firebase.cpp:10)
2023-11-17T22:45:41.068 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T03:43:36.206Z (firebase.cpp:11)
2023-11-17T22:45:41.068 -0600 [            ] [firebase] INFO     - Algo id: -NgMfgAZ7sLoQgIhImcG (firebase.cpp:13)
2023-11-17T22:45:41.063 -0600 [            ] [firebase] INFO     - Running Bollinger Bands Strategy (firebase.cpp:9)
2023-11-17T22:45:41.063 -0600 [            ] [firebase] INFO     - Description: The Bollinger Bands trading algorithm is a common and simple strategy. Bollinger Bands consist of a middle, upper, and lower "band". The middle band is a simple moving average of an asset's price, in my case, 20 days. The upper and lower bands are 2 standard deviations away from the middle band's value. Essentially, when the price touches/goes below the lower band it indicates that the asset is overbought and generates a buy signal, and when the price touches/goes above the upper band it indicates that the asset is oversold and generates a sell signal. 

This strategy takes into account price volatility and reversals. When volatility increases, bands widen and vice versa. By tracking these changes we can get a sense of how volatile the market is. When prices touch the upper and lower bands, we can anticipate a potential reversal in the other direction as it may suggest uptrends or downtrends that are overextended.  (firebase.cpp:10)
2023-11-17T22:45:41.063 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-09T03:06:42.998Z (firebase.cpp:11)
2023-11-17T22:45:41.063 -0600 [            ] [firebase] INFO     - Algo id: -NgHOU2wGG_YeyjrR7pf (firebase.cpp:13)
2023-11-17T22:45:41.070 -0600 [            ] [firebase] INFO     - Running Trial 2 (firebase.cpp:9)
2023-11-17T22:45:41.070 -0600 [            ] [firebase] INFO     - Description: trial (firebase.cpp:10)
2023-11-17T22:45:41.070 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T03:14:30.231Z (firebase.cpp:11)
2023-11-17T22:45:41.070 -0600 [            ] [firebase] INFO     - Algo id: -NgM_-U6aWXlq4xx3LCU (firebase.cpp:13)
2023-11-17T22:45:41.061 -0600 [            ] [rabbitmq] INFO     - Received init message from client DcYnNW4BbDZutN58w9IgZBbyKnY2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.061 -0600 [            ] [rabbitmq] INFO     - Received init message from client tfUPq1NibqWniLN1tWV12AS4LbB2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.073 -0600 [            ] [rabbitmq] INFO     - Received init message from client Yey7UiMacOhZzF3qq026sLFSy4s2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.071 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"Yey7UiMacOhZzF3qq026sLFSy4s2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.082 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.082 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.093 -0600 [            ] [firebase] INFO     - Running Market Maker (Cleaned) (firebase.cpp:9)
2023-11-17T22:45:41.093 -0600 [            ] [firebase] INFO     - Description: The goal for this algorithm is to make profit by capturing a fixed spread between buy and sell prices. Whenever trades trades are executed at a price, it adjusts to market conditions by putting in both buy and sell orders that will generate profitable margins.  (firebase.cpp:10)
2023-11-17T22:45:41.093 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-09T04:31:33.465Z (firebase.cpp:11)
2023-11-17T22:45:41.093 -0600 [            ] [firebase] INFO     - Algo id: -NgHh-XOO-QkBG1qjw3p (firebase.cpp:13)
2023-11-17T22:45:41.107 -0600 [            ] [firebase] WARNING  - User T4fV0y361Tfi0ZaikLYRgTy6YUh1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.107 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"T4fV0y361Tfi0ZaikLYRgTy6YUh1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.112 -0600 [            ] [firebase] WARNING  - User 2wFmpzWttiTv8Nph9dJcBefnvY03 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.112 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"2wFmpzWttiTv8Nph9dJcBefnvY03","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.135 -0600 [            ] [firebase] WARNING  - User 9VfgD1yx5aQ7XxUigQ5lflMkf9b2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.135 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"9VfgD1yx5aQ7XxUigQ5lflMkf9b2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.135 -0600 [            ] [firebase] INFO     - Running Test Submission (firebase.cpp:9)
2023-11-17T22:45:41.135 -0600 [            ] [firebase] INFO     - Description: See how the submission process works (firebase.cpp:10)
2023-11-17T22:45:41.135 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-03T17:27:36.799Z (firebase.cpp:11)
2023-11-17T22:45:41.135 -0600 [            ] [firebase] INFO     - Algo id: -Nfq_A8E-IbXD9ezOfoN (firebase.cpp:13)
2023-11-17T22:45:41.109 -0600 [            ] [rabbitmq] INFO     - Received init message from client T4fV0y361Tfi0ZaikLYRgTy6YUh1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.114 -0600 [            ] [rabbitmq] INFO     - Received init message from client 2wFmpzWttiTv8Nph9dJcBefnvY03 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.138 -0600 [            ] [rabbitmq] INFO     - Received init message from client 9VfgD1yx5aQ7XxUigQ5lflMkf9b2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.138 -0600 [            ] [firebase] INFO     - Running Algo.py (firebase.cpp:9)
2023-11-17T22:45:41.138 -0600 [            ] [firebase] INFO     - Description: This strategy uses Bollinger Bands, MACD, and RSI for signal generation
Incorporated a volatility-based mechanism to adjust the quantity of assets traded
Efficiently managed and updated price data using NumPy arrays, ensuring the strategy's responsiveness to market movements (firebase.cpp:10)
2023-11-17T22:45:41.138 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:52:45.804Z (firebase.cpp:11)
2023-11-17T22:45:41.138 -0600 [            ] [firebase] INFO     - Algo id: -NgMvWqOtH1v17niIfsX (firebase.cpp:13)
2023-11-17T22:45:41.141 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.141 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.121 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.121 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.143 -0600 [            ] [firebase] WARNING  - User QtIt3aQJaibz8BJ5jhdeaHpysmo2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.143 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"QtIt3aQJaibz8BJ5jhdeaHpysmo2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.146 -0600 [            ] [rabbitmq] INFO     - Received init message from client QtIt3aQJaibz8BJ5jhdeaHpysmo2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.150 -0600 [            ] [firebase] INFO     - Running yesyes (firebase.cpp:9)
2023-11-17T22:45:41.150 -0600 [            ] [firebase] INFO     - Description: yes (firebase.cpp:10)
2023-11-17T22:45:41.150 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:48:37.041Z (firebase.cpp:11)
2023-11-17T22:45:41.150 -0600 [            ] [firebase] INFO     - Algo id: -NgMuZ5Zy74kdoVHtc7r (firebase.cpp:13)
2023-11-17T22:45:41.172 -0600 [            ] [firebase] INFO     - Running Golden/Death Cross (firebase.cpp:9)
2023-11-17T22:45:41.172 -0600 [            ] [firebase] INFO     - Description: In essence, this algorithm calculates short- and long- term moving averages and compare them to make trading decisions.

When the short-term MA crosses the long-term MA from bottom, it is a signal to buy. Multiple long-term MAs are set and the longer the term for MA, it is less likely for the short-term MA to cross it so it associates with a larger trading quantity. On the contract, if it crosses from top, it is a signal to sell. 

Since no basic information about the environment (e.g. liquidity, size, etc.) are provided, many coefficient may be unrealistic/inappropriate. No time-series data is given (no on_tick function or the time where trading happens) so the short and long MAs are referred to the number of historical trading prices instead of time. Furthermore, canceling orders seems to be impossible and this may lead to problems. However, I did organized data required to perform canceling if such a function is given. 

Without the simulated environment it is hard to test the model and configure functions. Hence, some implementations are simplified. Please read my code and comments for more details. Thank you! (firebase.cpp:10)
2023-11-17T22:45:41.172 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:11:11.545Z (firebase.cpp:11)
2023-11-17T22:45:41.172 -0600 [            ] [firebase] INFO     - Algo id: -NgMlLVl74x9E_LE5uI0 (firebase.cpp:13)
2023-11-17T22:45:41.178 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.178 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.179 -0600 [            ] [firebase] WARNING  - User ih4Zrbi50wOcIeH0X0ClJZFpxKO2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.179 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"ih4Zrbi50wOcIeH0X0ClJZFpxKO2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.173 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.173 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.174 -0600 [            ] [firebase] INFO     - Running SMA and EMA matching with prices (firebase.cpp:9)
2023-11-17T22:45:41.174 -0600 [            ] [firebase] INFO     - Description: Buy when EMA > SMA, and sell when SMA > EMA. Determine price to buy/sell by comparing EMA/SMA with potential orders, and determine quantity by deciding to invest portions of capital. (firebase.cpp:10)
2023-11-17T22:45:41.174 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-09T22:37:29.572Z (firebase.cpp:11)
2023-11-17T22:45:41.174 -0600 [            ] [firebase] INFO     - Algo id: -NgL_dJ_4Wg5M1Uug1Qu (firebase.cpp:13)
2023-11-17T22:45:41.186 -0600 [            ] [firebase] WARNING  - User WixRCfSehNO23MwGF7ZCy9ATnTC2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.186 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"WixRCfSehNO23MwGF7ZCy9ATnTC2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:40.826 -0600 [            ] [main    ] INFO     - Logging initialized! (logging.cpp:119)
2023-11-17T22:45:40.826 -0600 [            ] [main    ] INFO     - NUTC Client: Interface to the NUFT Trading Competition (main.cpp:75)
2023-11-17T22:45:40.826 -0600 [            ] [main    ] INFO     - Built from d82eb5a on main (main.cpp:78)
2023-11-17T22:45:40.826 -0600 [            ] [main    ] INFO     - Starting NUTC Client for UID GtPsjOf76iSCNKVkR1LgLmu9AoC3 (main.cpp:96)
2023-11-17T22:45:41.000 -0600 [            ] [rabbitmq] INFO     - Connection established (rabbitmq.cpp:222)
2023-11-17T22:45:41.183 -0600 [            ] [rabbitmq] INFO     - Received init message from client ih4Zrbi50wOcIeH0X0ClJZFpxKO2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.190 -0600 [            ] [rabbitmq] INFO     - Received init message from client WixRCfSehNO23MwGF7ZCy9ATnTC2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.189 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.189 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.202 -0600 [            ] [firebase] INFO     - Running alg1 (firebase.cpp:9)
2023-11-17T22:45:41.202 -0600 [            ] [firebase] INFO     - Description: alg1 description (firebase.cpp:10)
2023-11-17T22:45:41.202 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-08T23:19:55.257Z (firebase.cpp:11)
2023-11-17T22:45:41.202 -0600 [            ] [firebase] INFO     - Algo id: -NgKiVvgOQFGIrNfWhjn (firebase.cpp:13)
2023-11-17T22:45:41.208 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"oa59DwAVcwUSwJfR2stT9CUbfz72","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.208 -0600 [            ] [firebase] INFO     - Running Syntax erro (firebase.cpp:9)
2023-11-17T22:45:41.208 -0600 [            ] [firebase] INFO     - Description: syntax (firebase.cpp:10)
2023-11-17T22:45:41.208 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-21T16:58:03.612Z (firebase.cpp:11)
2023-11-17T22:45:41.208 -0600 [            ] [firebase] INFO     - Algo id: -NhIA0f01ucaUPpLhDpa (firebase.cpp:13)
2023-11-17T22:45:41.211 -0600 [            ] [rabbitmq] INFO     - Received init message from client oa59DwAVcwUSwJfR2stT9CUbfz72 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.227 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"WMD3NPaAoETLALeg7IQuU0N2c1y1","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.222 -0600 [            ] [rabbitmq] INFO     - Received init message from client 4F0BgYAoEnX8A8mIriFNdUaoSXG2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.215 -0600 [            ] [firebase] WARNING  - User 4F0BgYAoEnX8A8mIriFNdUaoSXG2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.215 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"4F0BgYAoEnX8A8mIriFNdUaoSXG2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.230 -0600 [            ] [rabbitmq] INFO     - Received init message from client WMD3NPaAoETLALeg7IQuU0N2c1y1 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.237 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.237 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.237 -0600 [            ] [rabbitmq] INFO     - Received init message from client dLqi77gh7iR8GrOvGASkHLKl6Zv1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.235 -0600 [            ] [firebase] WARNING  - User dLqi77gh7iR8GrOvGASkHLKl6Zv1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.235 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"dLqi77gh7iR8GrOvGASkHLKl6Zv1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.256 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"Wz6CZ7hopkVNDFHBk4dwymKdtSn2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.258 -0600 [            ] [rabbitmq] INFO     - Received init message from client Wz6CZ7hopkVNDFHBk4dwymKdtSn2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.272 -0600 [            ] [rabbitmq] INFO     - Received init message from client lYTpRGcLfJZGas4kyXc8DfpmJuz1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.269 -0600 [            ] [firebase] WARNING  - User lYTpRGcLfJZGas4kyXc8DfpmJuz1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.269 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"lYTpRGcLfJZGas4kyXc8DfpmJuz1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.342 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"vzZV25SctsUZOFPpptE8XXYFP6h2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.349 -0600 [            ] [rabbitmq] INFO     - Received init message from client vzZV25SctsUZOFPpptE8XXYFP6h2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.359 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"33eij2KE0vVWqOx2buv1fYxwiB72","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.361 -0600 [            ] [firebase] INFO     - Running slope attempt idk how many (firebase.cpp:9)
2023-11-17T22:45:41.361 -0600 [            ] [firebase] INFO     - Description: take the slope  of hi and low and run with it

(please work??) (firebase.cpp:10)
2023-11-17T22:45:41.361 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:10:38.476Z (firebase.cpp:11)
2023-11-17T22:45:41.361 -0600 [            ] [firebase] INFO     - Algo id: -NgMlqDjMMbF1guzeE75 (firebase.cpp:13)
2023-11-17T22:45:41.364 -0600 [            ] [rabbitmq] INFO     - Received init message from client 33eij2KE0vVWqOx2buv1fYxwiB72 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.364 -0600 [            ] [rabbitmq] INFO     - Received init message from client CwwxcKXgT3dtGLMi9dwZnD7fqwg1 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.361 -0600 [            ] [firebase] WARNING  - User CwwxcKXgT3dtGLMi9dwZnD7fqwg1 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.361 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"CwwxcKXgT3dtGLMi9dwZnD7fqwg1","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.369 -0600 [            ] [firebase] INFO     - Running I hope this works (Kevin Li's algorithm) (firebase.cpp:9)
2023-11-17T22:45:41.369 -0600 [            ] [firebase] INFO     - Description: This algorithm implements a variant of the MACD trading strategy. It determines buy or sell signals based on MACD and Signal line crossovers, combined with the RSI to gauge overbought or oversold conditions. When a buy condition is met, a fraction of available capital is invested; on a sell signal, a fraction of the owned stocks is sold. (firebase.cpp:10)
2023-11-17T22:45:41.369 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-10T04:14:47.037Z (firebase.cpp:11)
2023-11-17T22:45:41.369 -0600 [            ] [firebase] INFO     - Algo id: -NgMmYGHRX-XyiktdePg (firebase.cpp:13)
2023-11-17T22:45:41.378 -0600 [            ] [rabbitmq] INFO     - Received init message from client 1Pd1lJUMPURc0ezL393vWwRz9g32 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.375 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"1Pd1lJUMPURc0ezL393vWwRz9g32","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.382 -0600 [            ] [firebase] WARNING  - User 2jt06RLdlDUIg7xtTJEGEXlp3Pr2 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.382 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"2jt06RLdlDUIg7xtTJEGEXlp3Pr2","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.382 -0600 [            ] [firebase] INFO     - Running test (firebase.cpp:9)
2023-11-17T22:45:41.382 -0600 [            ] [firebase] INFO     - Description: test (firebase.cpp:10)
2023-11-17T22:45:41.382 -0600 [            ] [firebase] INFO     - Upload date: 2023-10-05T00:15:53.971Z (firebase.cpp:11)
2023-11-17T22:45:41.382 -0600 [            ] [firebase] INFO     - Algo id: -NfxBC2FIyI5iX-xiOVQ (firebase.cpp:13)
2023-11-17T22:45:41.384 -0600 [            ] [rabbitmq] INFO     - Received init message from client 2jt06RLdlDUIg7xtTJEGEXlp3Pr2 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.385 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.385 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.388 -0600 [            ] [rabbitmq] INFO     - Received init message from client GtPsjOf76iSCNKVkR1LgLmu9AoC3 with status not ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.386 -0600 [            ] [firebase] WARNING  - User GtPsjOf76iSCNKVkR1LgLmu9AoC3 has no algos. Will not participate in simulation. (firebase.cpp:65)
2023-11-17T22:45:41.386 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"GtPsjOf76iSCNKVkR1LgLmu9AoC3","ready":false} (rabbitmq.cpp:280)
2023-11-17T22:45:41.402 -0600 [            ] [rabbitmq] INFO     - Received init message from client HPl7qB7JXVPr8whA5CdeHkiIJgy2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.398 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"HPl7qB7JXVPr8whA5CdeHkiIJgy2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.424 -0600 [            ] [rabbitmq] INFO     - Received init message from client Dk8MZi5waHdXwcCbeTQIFdS7Q242 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.422 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"Dk8MZi5waHdXwcCbeTQIFdS7Q242","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.422 -0600 [            ] [py_runtime] INFO     - Running code:
import numpy as np
import pandas as pd
from statistics import mean

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""
    short = 4
    long = 10
    threshold = 0.01
    A = ([], 0, "A")
    B = ([], 0, "B")
    C = ([], 0, "C")

    def __init__(self) -> None:
        ''''''

    def strategy(self, stock) -> None:
        if len(stock[0]) > 10 and len(stock[1]) > 10:
            def calc_avg(type, len):
                count = 0
                sum = 0
                for i in type:
                    if count == len:
                        break
                    sum += i[0]
                    count += 1
                return sum / len
            short_avg = calc_avg(stock[0], self.short)
            long_avg = calc_avg(stock[0], self.long)

            if short_avg > long_avg:
                if stock[2] != 1:
                    stock[2] = 1
                    place_market_order("BUY", stock[3], np.log(short_avg - long_avg), short_avg)
            elif short_avg < long_avg:
                if stock[2] != -1:
                    stock[2] = -1
                    place_market_order("SELL", stock[3], np.log(long_avg - short_avg), short_avg)
        else:
            None
        

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        def bns(stock) -> None:
            stock[0].insert(0, (price, quantity))
        if ticker == "A":
            bns(self.A)
            self.strategy(self.A)
        elif ticker == "B":
            bns(self.B)
            self.strategy(self.B)
        elif ticker == "C":
            bns(self.C)
            self.strategy(self.C)

        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        ) (pywrapper.cpp:50)
2023-11-17T22:45:41.424 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.424 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.429 -0600 [            ] [rabbitmq] INFO     - Received init message from client 7NVpuKjZHZecKZDLSbisIhFf9i73 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.469 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"2cYNlCFxizV2eOV8jiOA2RxYybd2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.427 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"7NVpuKjZHZecKZDLSbisIhFf9i73","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.471 -0600 [            ] [rabbitmq] INFO     - Received init message from client 2cYNlCFxizV2eOV8jiOA2RxYybd2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.540 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"4KwPAaSMcaUCyYEQVShsWb0J2wk2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.540 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"02KqrrLYSVgUGzIGN2H57LnmxeP2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.542 -0600 [            ] [rabbitmq] INFO     - Received init message from client 02KqrrLYSVgUGzIGN2H57LnmxeP2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.542 -0600 [            ] [rabbitmq] INFO     - Received init message from client 4KwPAaSMcaUCyYEQVShsWb0J2wk2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.542 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"FosRw3EWkkbDKINqLjGc5LN2pQo2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.542 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"2EpG9YUMr5NtGPwgZCwFiTKpOVK2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.573 -0600 [            ] [py_runtime] INFO     - Running code:
from collections import defaultdict
import math
import time


def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """


class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""
        self.stocks = defaultdict(lambda: 0)
        self.totalOrders = defaultdict(lambda: 0)
        self.momentum = defaultdict(lambda: 0)
        self.pending_orders = defaultdict(lambda: 0)

        self.totalQuantity = 0
        self.currentHoldings = defaultdict(lambda: [0, 0])
        self.cash = 1e5
        self.maxSpend = 0.2
        self.mmax = 3
        self.alpha = 0.4
        self.lossThresh = 0.8
        self.pendingStockLimit = 10

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        self.totalOrders[ticker] += 1
        if (self.stocks[ticker] > 0):
            self.momentum[ticker] = self.alpha * self.momentum[ticker] + \
                (1 - self.alpha) * \
                ((price - self.stocks[ticker]) / self.stocks[ticker]) * \
                (quantity / (self.totalQuantity / self.totalOrders[ticker]))

            if (self.momentum[ticker] > self.mmax):
                self.momentum[ticker] = self.mmax
            if (self.momentum[ticker] < -self.mmax):
                self.momentum[ticker] = -self.mmax
        self.stocks[ticker] = price
        self.totalQuantity += quantity
        # print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.
        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """

        if (side == "BUY"):
            if (self.momentum[ticker] < 0 and self.currentHoldings[ticker][1] > 0 and abs(self.pending_orders[ticker]) <= self.pendingStockLimit):
                if (self.momentum[ticker] < -self.mmax/2 or price >= self.lossThresh * self.currentHoldings[ticker][0]):
                    value = place_market_order(
                        "SELL", ticker, self.currentHoldings[ticker][1], price)

                    while value == False:
                        time.sleep(1)
                        value = place_market_order(
                            "SELL", ticker, self.currentHoldings[ticker][1], price)
                    self.pending_orders[ticker] -= self.currentHoldings[ticker][1]
        else:
            if (self.momentum[ticker] > 0 and abs(self.pending_orders[ticker]) <= self.pendingStockLimit):
                value = place_market_order("BUY", ticker, min(math.floor(
                    self.maxSpend * self.cash / price), quantity), price)

                while value == False:
                    time.sleep(1)
                    value = place_market_order("BUY", ticker, min(math.floor(
                        self.maxSpend * self.cash / price), quantity), price)
                self.pending_orders[ticker] += min(math.floor(
                    self.maxSpend * self.cash / price), quantity)

        # print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """

        self.cash = capital_remaining

        if side == "BUY":
            self.currentHoldings[ticker][0] = (self.currentHoldings[ticker][0] * self.currentHoldings[ticker]
                                               [1] + price * quantity) / (self.currentHoldings[ticker][1] + quantity)
            self.currentHoldings[ticker][1] += quantity
            self.pending_orders[ticker] -= quantity
        else:
            self.currentHoldings[ticker][1] -= quantity
            self.pending_orders[ticker] += quantity

        # print(
        #     f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        # )


# x = Strategy()

# x.on_trade_update(
#     "AAPL",
#     "BUY",

#     30,
#     25,
# )

# x.on_trade_update(
#     "AAPL",
#     "BUY",

#     40,
#     25,
# )

# x.on_orderbook_update(
#     "AAPL", "SELL", 25, 15
# )
# x.on_account_update(
#     "AAPL",
#     "BUY",
#     30,
#     25,
#     95000,
# )
 (pywrapper.cpp:50)
2023-11-17T22:45:41.543 -0600 [            ] [rabbitmq] INFO     - Received init message from client 2EpG9YUMr5NtGPwgZCwFiTKpOVK2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.544 -0600 [            ] [rabbitmq] INFO     - Received init message from client FosRw3EWkkbDKINqLjGc5LN2pQo2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.578 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.578 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.582 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"GzdWwQ2lqpVTcGXPBz1y6gISOBG2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.618 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"1CwzMEOkmycXyz7LYY2HsXtFH043","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.620 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"MBjWWpExpOWPXNr3gLL9h7LgxDy2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.618 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"Cgr9vwsL8iUWI7xJ2dDYtwWzpmm1","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.582 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"WEZuwN7bFhNqRTLTFR1UFsJ5eEe2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.596 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"t6Svz58isiVhuarKJPg3Hjd3Eqq2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.584 -0600 [            ] [rabbitmq] INFO     - Received init message from client WEZuwN7bFhNqRTLTFR1UFsJ5eEe2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.584 -0600 [            ] [rabbitmq] INFO     - Received init message from client GzdWwQ2lqpVTcGXPBz1y6gISOBG2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.598 -0600 [            ] [rabbitmq] INFO     - Received init message from client t6Svz58isiVhuarKJPg3Hjd3Eqq2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.619 -0600 [            ] [rabbitmq] INFO     - Received init message from client 1CwzMEOkmycXyz7LYY2HsXtFH043 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.619 -0600 [            ] [rabbitmq] INFO     - Received init message from client Cgr9vwsL8iUWI7xJ2dDYtwWzpmm1 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.621 -0600 [            ] [rabbitmq] INFO     - Received init message from client MBjWWpExpOWPXNr3gLL9h7LgxDy2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.586 -0600 [            ] [py_runtime] INFO     - Running code:
import pandas as pd
import numpy as np
import time

#long_short_MA_min_risk_2.0
# Simple trading algorithm that generates a buy signal if the short term (25 transactions) VWAP crosses above the 
# long term (200 transactions) and vice versa.
# Also minimizes the risk so that a flag to sell occurs when 2% of capital is lost from 
# when order was placed
import pandas as pd
import numpy as np
import time

# Define a timeout constant (in seconds) for the while loops
TIMEOUT_SECONDS = 60

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY"""
    # Simulate placing a market order here
    time.sleep(0.5)  # Simulate order placement delay
    return True  # Return True for successful order placement (modify as needed)

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        self.cap = 100000  # Initial capital
        self.short_window = 25  # Short-term moving average window
        self.long_window = 200  # Long-term moving average window
        self.positions = {}  # Dictionary to track positions
        self.data = pd.DataFrame(columns=['transaction_number', 'ticker', 'price', 'volume'])  # DataFrame to track order updates
        self.stop_order_data = {'A': pd.DataFrame(columns=['quantity', 'stop_loss_price', 'filled']),
                                'B': pd.DataFrame(columns=['quantity', 'stop_loss_price', 'filled']),
                                'C': pd.DataFrame(columns=['quantity', 'stop_loss_price', 'filled'])}
        self.LOB_buy = {'A': pd.DataFrame(columns=['quantity', 'price', 'order_place']),
                        'B': pd.DataFrame(columns=['quantity', 'price', 'order_place']),
                        'C': pd.DataFrame(columns=['quantity', 'price', 'order_place'])}
        self.LOB_sell = {'A': pd.DataFrame(columns=['quantity', 'price', 'order_place']),
                         'B': pd.DataFrame(columns=['quantity', 'price', 'order_place']),
                         'C': pd.DataFrame(columns=['quantity', 'price', 'order_place'])}
        self.last_filled = 0
        self.ticker_data = {}
        self.transaction_number = 0
        self.buy_number = {'A': 0, 'B': 0, 'C': 0}
        self.update_number = {'A': 0, 'B': 0, 'C': 0}
        self.time = time.time()

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders."""
        self.transaction_number += 1
        temp_df = pd.DataFrame(data={'transaction_number': self.transaction_number,
                                     'ticker': ticker,
                                     'price': price,
                                     'volume': quantity}, index=[self.transaction_number])
        self.data = pd.concat([self.data, temp_df], ignore_index=True)

        if ticker not in self.ticker_data:
            self.ticker_data[ticker] = pd.DataFrame(columns=['transaction_number', 'price', 'volume'])
        self.ticker_data[ticker] = pd.concat([self.ticker_data[ticker], temp_df[['transaction_number', 'price', 'volume']]], ignore_index=True)

        # Stop loss order update
        risk_signal = True
        while risk_signal and (time.time() - self.time) < TIMEOUT_SECONDS:
            unfilled = self.stop_order_data[ticker].loc[self.stop_order_data[ticker]['filled'] == False]
            if not unfilled.empty:
                position_min_price = unfilled['stop_loss_price'].idxmin()
                if unfilled.loc[position_min_price, 'stop_loss_price'] <= self.last_filled:
                    is_through = False
                    while not is_through and (time.time() - self.time) < TIMEOUT_SECONDS:
                        is_through = place_market_order("SELL", ticker, unfilled.loc[position_min_price, 'quantity'],
                                                        self.LOB_buy[ticker].iloc[0, 1])
                    if is_through:
                        self.stop_order_data[ticker].loc[position_min_price, 'filled'] = True
                else:
                    risk_signal = False

        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both."""
        if side == "BUY":
            quantity_to_be_matched = quantity
            if len(self.LOB_sell[ticker]) > 0:
                sorted_LOB_sell = self.LOB_sell[ticker].sort_values(by=['price'], ascending=False)
                if price < sorted_LOB_sell.iloc[0, 1]:
                    while quantity_to_be_matched > 0 and not sorted_LOB_sell.empty:
                        if sorted_LOB_sell.iloc[0, 1] > price:
                            if sorted_LOB_sell.iloc[0, 0] <= quantity_to_be_matched:
                                quantity_to_be_matched = quantity_to_be_matched - sorted_LOB_sell.iloc[0, 0]
                                sorted_LOB_sell = sorted_LOB_sell.iloc[1:]
                            else:
                                sorted_LOB_sell.iloc[0, 0] = sorted_LOB_sell.iloc[0, 0] - quantity_to_be_matched
                                quantity_to_be_matched = 0
                        else:
                            break
                self.LOB_sell[ticker] = sorted_LOB_sell

            if quantity_to_be_matched > 0:
                self.update_number[ticker] += 1
                temp_LOB_buy_df = pd.DataFrame(data={'quantity': quantity_to_be_matched,
                                                    'price': price,
                                                    'order_place': self.update_number[ticker]},
                                               index=[self.update_number[ticker]])
                self.LOB_buy[ticker] = pd.concat([self.LOB_buy[ticker], temp_LOB_buy_df])

        if side == "SELL":
            quantity_to_be_matched = quantity
            if len(self.LOB_buy[ticker]) > 0:
                sorted_LOB_buy = self.LOB_buy[ticker].sort_values(by=['price'], ascending=False)
                if price < sorted_LOB_buy.iloc[0, 1]:
                    while quantity_to_be_matched > 0 and not sorted_LOB_buy.empty:
                        if sorted_LOB_buy.iloc[0, 1] > price:
                            if sorted_LOB_buy.iloc[0, 0] <= quantity_to_be_matched:
                                quantity_to_be_matched = quantity_to_be_matched - sorted_LOB_buy.iloc[0, 0]
                                self.last_filled = max(price, sorted_LOB_buy.iloc[0, 1])
                                sorted_LOB_buy = sorted_LOB_buy.iloc[1:]
                            else:
                                sorted_LOB_buy.iloc[0, 0] = sorted_LOB_buy.iloc[0, 0] - quantity_to_be_matched
                                self.last_filled = max(price, sorted_LOB_buy.iloc[0, 1])
                                quantity_to_be_matched = 0

                        else:
                            break
                self.LOB_buy[ticker] = sorted_LOB_buy

            if quantity_to_be_matched > 0:
                self.update_number[ticker] += 1
                temp_LOB_sell_df = pd.DataFrame(data={'quantity': quantity_to_be_matched,
                                                     'price': price,
                                                     'order_place': self.update_number[ticker]},
                                                index=[self.update_number[ticker]])
                self.LOB_sell[ticker] = pd.concat([self.LOB_sell[ticker], temp_LOB_sell_df])

        if (time.time() - self.time) > 2:
            self.time = time.time()
            self.moving_average_compare()

        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(self, ticker: str, side: str, price: float, quantity: float, capital_remaining: float) -> None:
        """Called whenever one of your orders is filled."""
        self.cap = capital_remaining

        if side == "BUY":
            risk_percentage = 0.02
            max_loss = self.cap * risk_percentage
            entry_price = price
            stop_loss_price = entry_price - max_loss / quantity

            self.buy_number[ticker] += 1
            temp_stop_loss_df = pd.DataFrame(data={'quantity': quantity,
                                                   'stop_loss_price': stop_loss_price,
                                                   'filled': False},
                                             index=[self.buy_number[ticker]])
            self.stop_order_data[ticker] = pd.concat([self.stop_order_data[ticker], temp_stop_loss_df])

        elif side == "SELL":
            quantity_tracker = quantity
            while quantity_tracker > 0:
                unfilled = self.stop_order_data[ticker].loc[self.stop_order_data[ticker]['filled'] == False]
                if not unfilled.empty:
                    position_min_price = unfilled['stop_loss_price'].idxmin()
                    is_through = False
                    while not is_through and (time.time() - self.time) < TIMEOUT_SECONDS:
                        is_through = place_market_order("SELL", ticker, unfilled.loc[position_min_price, 'quantity'], price)
                    if is_through:
                        self.stop_order_data[ticker].loc[position_min_price, 'filled'] = True
                        quantity_tracker = quantity_tracker - self.stop_order_data[ticker].loc[position_min_price, 'quantity']

        print(f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}")

    def calculate_moving_averages(self, ticker):
        """Calculate short-term and long-term moving averages for a specific ticker."""
        ticker_data = self.ticker_data[ticker]
        ticker_data['v_price'] = ticker_data['price'] * ticker_data['volume']
        ticker_data['VWAP_long'] = ticker_data['v_price'].rolling(window=self.long_window, min_periods=1).mean() / \
                                    ticker_data['volume'].rolling(window=self.long_window, min_periods=1).mean()
        ticker_data['VWAP_short'] = ticker_data['v_price'].rolling(window=self.short_window, min_periods=1).mean() / \
                                     ticker_data['volume'].rolling(window=self.short_window, min_periods=1).mean()

    def moving_average_compare(self):
        """Implement your trading strategy here."""
        for ticker in self.ticker_data:
            self.calculate_moving_averages(ticker)
            order_amount = 200
            ticker_data = self.ticker_data[ticker]
            signals = ticker_data['VWAP_short'] > ticker_data['VWAP_long']
            signals = signals.astype(int)

            if len(signals >= 2) and signals[-1] > signals[-2]:
                if ticker not in self.positions:
                    self.positions[ticker] = 0
                self.positions[ticker] += order_amount

                is_through = False
                self.time = time.time()
                while not is_through and (time.time() - self.time) < TIMEOUT_SECONDS:
                    is_through = place_market_order("BUY", ticker, order_amount, ticker_data.iloc[-1]['price'])

            elif len(signals >= 2) and signals[-1] < signals[-2]:
                if ticker in self.positions and self.positions[ticker] > 0:
                    self.positions[ticker] -= order_amount

                    is_through = False
                    self.time = time.time()
                    while not is_through and (time.time() - self.time) < TIMEOUT_SECONDS:
                        is_through = place_market_order("SELL", ticker, order_amount, ticker_data.iloc[-1]['price'])

 (pywrapper.cpp:50)
2023-11-17T22:45:41.589 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.589 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.648 -0600 [            ] [py_runtime] INFO     - Running code:
import time

import numpy as np
import math

import queue


def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """


class Strategy:
    """Template for a strategy."""

    
    def __init__(self) -> None:
        self._capital = 100000
        
        self._curr_holdings = {
            'A': 0,
            'B': 0,
            'C': 0
        }

        self._orderbook = {
            'SELL': {
                        'A' : {},
                        'B' : {},
                        'C' : {}
                    },
            'BUY': {
                        'A' : {},
                        'B' : {},
                        'C' : {}
                    }
        }
        # Average price, quantity
        self._average_price = {
            'A': [0, 0],
            'B': [0, 0],
            'C': [0, 0]
        }
        self._last_twenty ={
            'A' : queue.Queue(),
            'B' : queue.Queue(),
            'C' : queue.Queue()
        }  
        self._can_trade = False
        #time.sleep(11)
        self._can_trade = True
        self._begin_average_price = self._average_price

        

    def _amount_to_buy(self):
        if self._capital < 15000:
            return math.log2(self._capital * 8)
        else: 
            return (self._capital ** 1.02) * 0.003 
        
    def _amount_to_sell(self, ticker, sell_price):
        if sell_price *self._curr_holdings[ticker]  < 5000:
            return math.log2(self._capital * 8)
        else: 
            return ((sell_price * self._curr_holdings[ticker]) ** 1.01) * 0.012 

    def _last_twenty_average(self, ticker):
        temp_queue = self._last_twenty[ticker]

        total_temp = 0
        count = 0

        while not temp_queue.empty():
            temp = temp_queue.get()
            total_temp += temp
            count += 1

        # Calculate the average temperature
        if count > 0:
            average_temp = total_temp / count
            return average_temp
        else:
            return 0
        

    def _trade_algo(self):
            buy_rating = {
            'A' : 0,
            'B' : 0,
            'C' : 0
            }

            sell_rating = {
                'A' : 0,
                'B' : 0,
                'C' : 0
            }
            for key in buy_rating.keys():
                buy_rating[key] = ((0.7 * self._average_price[key][0]+ 0.3 * self._begin_average_price[key][0]) / (self._calc_liquid_sell(key)[0]))
            
            if (0.7 * self._average_price[key][0] + 0.3 * self._begin_average_price[key][0]) > 0:
                for sell_key in sell_rating.keys():
                    sell_rating[sell_key] = ((self._calc_liquid_buy(sell_key)[0] /(0.7 * self._average_price[sell_key][0] + 0.3 * self._begin_average_price[sell_key][0])))
            
            best_buy_key = max(buy_rating, key=lambda key: buy_rating[key])
            best_sell_key = max(buy_rating, key=lambda key: buy_rating[key])
            amount_buy = ((buy_rating[best_buy_key] ** 2) * self._amount_to_buy()) 
            buy_price = self._last_twenty_average(best_buy_key) * 0.9 + 0.1 * self._calc_liquid_sell(key)[0]
            sell_price = self._last_twenty_average(best_sell_key) * 0.9 + 0.1 * self._calc_liquid_buy(key)[0]
            amount_sell = ((buy_rating[best_sell_key] ** 2) * self._amount_to_sell(key, sell_price))


            if (amount_buy < self._capital) and (buy_rating[best_buy_key] > 1):
                place_market_order("BUY", best_buy_key, amount_buy / buy_price , buy_price)

            if (amount_buy < self._capital) and (sell_rating[best_sell_key] > 1):
                place_market_order("SELL", best_sell_key, amount_sell / sell_price, sell_price)

        

   
   
   
    def _calc_liquid_buy(self, ticker: str):
        
        total_value = [key * value for key, value in self._orderbook['BUY'][ticker].items()]
        print(total_value)
        if not total_value:
            return (1, 1)
        total_value_75th = np.percentile(total_value, 75)
        print(total_value_75th)

            
        adjusted_liquidity = 0
        total_quantity = 0

        for quantity, price in self._orderbook['BUY'][ticker].items():
            if total_value_75th - total_value_75th * 0.1 <= price:
                adjusted_liquidity = quantity*price
                total_quantity += quantity 

        average_liquidity = adjusted_liquidity/total_quantity
        return (average_liquidity, total_quantity) 
    
    def _calc_liquid_sell(self, ticker: str):
        total_value = [key * value for key, value in self._orderbook['SELL'][ticker].items()]
        if not total_value:
            return (1, 1)
        total_value_25th = np.percentile(total_value, 25)
       
        

        adjusted_liquidity = 0
        total_quantity = 0

        for quantity, price in self._orderbook['SELL'][ticker].items():
            if total_value_25th + total_value_25th * 0.1 >= price:
                adjusted_liquidity = quantity*price
                total_quantity += quantity 
            
        average_liquidity = adjusted_liquidity/total_quantity
        return (average_liquidity, total_quantity) 


    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")
        self._average_price[ticker][0] = (self._average_price[ticker][0] * self._average_price[ticker][1] + price + quantity)/(self._average_price[ticker][1] + quantity)
        self._average_price[ticker][1] += quantity
        
        self._last_twenty[ticker].put(price)

        while self._last_twenty[ticker].qsize() > 20:
            self._last_twenty[ticker].get()


    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        if self._orderbook[side][ticker].get(price) is None or self._orderbook[side][ticker].get(price) < 0.001:
            self._orderbook[side][ticker][price] = quantity
        else: 
            self._orderbook[side][ticker][price] =  self._orderbook[side][ticker][price] + quantity

        if self._can_trade:
            self._trade_algo()


        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Amount of capital after fulfilling order
        """
        if side == "BUY":
            self._curr_holdings[ticker] = self._curr_holdings[ticker] + quantity
        else: 
            self._curr_holdings[ticker] = self._curr_holdings[ticker] - quantity

        self._capital = capital_remaining
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:41.650 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.650 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.696 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"6tMJ4MbOd6fTpUYDUGTiB2Ujnni2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.700 -0600 [            ] [rabbitmq] INFO     - Received init message from client 6tMJ4MbOd6fTpUYDUGTiB2Ujnni2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.739 -0600 [            ] [rabbitmq] INFO     - Received init message from client 6NfTjMvkhJSJJ3JFD1eGTYXTVSl2 with status ready (RabbitMQClientManager.cpp:36)
2023-11-17T22:45:41.735 -0600 [            ] [rabbitmq] INFO     - Publishing init message: {"client_uid":"6NfTjMvkhJSJJ3JFD1eGTYXTVSl2","ready":true} (rabbitmq.cpp:280)
2023-11-17T22:45:41.826 -0600 [            ] [py_runtime] INFO     - Running code:
# -*- coding: utf-8 -*-
"""svm_stock_predictor

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TETBsIt4WYjrECp50BKUM4VdRJXwhiTy
"""

import pandas as pd
import numpy as np
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split

#Yahoo_data = pd.read_csv('AAPL, BRK-B.csv')

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self, df, ticker):
    # eg: Strategy(Yahoo_data, 'AAPL')
      self.ticker = ticker
      self.df = df[df['Ticker'] == ticker]
      #print('init')

    def svm_model_creation(self):
      #prepare the inputs for the SVM
      lags = 5
      test_size = 0.2
      kernel = 'linear'

      #set up the inputs and target outputs. The inputs are the past 5 close price and is created with the lags
      y = self.df['Close'].values
      y = pd.Series(y)
      x = pd.DataFrame({'lag_{}'.format(i): y.shift(i) for i in range(lags)})

      x.dropna(inplace=True)
      y = y[lags+1:]

      #print(len(X), len(df))

      lagged_df = self.df.drop(self.df.index[:(lags-1)])
      x['Date'] = lagged_df['Date']

      #split into training and testing data. Used first 9 months of past year for training
      x['Date'] = pd.to_datetime(x['Date'])
      date_cutoff = '2023-05-07'
      x_train = x.loc[x['Date'] < date_cutoff]
      x_test = x.loc[x['Date'] >= date_cutoff]
      y_train = y[0:len(x_train)]
      y_test = y[-(len(x_test)+1):-1]

      x_train = x_train.drop(columns = 'Date')
      x_test = x_test.drop(columns = 'Date')

      #train the SVM
      svm_regressor = SVR(kernel=kernel)
      svm_regressor.fit(x_train, y_train)


      y_pred = svm_regressor.predict(x_test)

      #test how accurate the SVM is with the past 3 months of data
      print('value prediction MSE: ', mean_squared_error(y_test, y_pred))
      #print(len(y_pred), len(y_test))


      plt.scatter([i for i in range(1, len(y_test)+1)], y_test, label='actual test data', color='blue', marker='o')

      plt.scatter([i for i in range(1, len(y_pred)+1)], y_pred, label='predictions based on training data', color='red', marker='o')

      plt.xlabel('Day number')
      plt.ylabel('value ($)')
      plt.legend()
      plt.title(self.ticker)

      plt.show()

      #call differences method
      self.differences(y_pred, y_test)




    def differences(self, y_pred, y_test):
      #based on the plot from svm_model_creation, the model is better at predicting the day to day change than predicting the actual values
      #deciding to buy a stock will be based on the predicited day to day change

      #print(y_pred, y_test)
      y_pred = pd.Series(y_pred)
      y_test = y_test.values

      pred_differences = [y_pred[i+1] - y_pred[i] for i in range(len(y_pred)-1)]
      test_differences = [y_test[i+1] - y_test[i] for i in range(len(y_test)-1)]

      #print('differences MSE: ', mean_squared_error(pred_differences, test_differences))


      plt.scatter([i for i in range(1, len(y_test))], test_differences, label='actual test differences', color='blue', marker='o')

      plt.scatter([i for i in range(2, len(y_pred)+1)], pred_differences, label='predicted differences based on training data', color='red', marker='o')

      plt.xlabel('Day number')
      plt.ylabel('day to day difference ($)')
      plt.legend()
      plt.title(self.ticker + ' differences')


      plt.show()

      # buy 100 stocks if the stock is predicted to increase by more than 3%
      if pred_differences[-1] > .03 * test_differences[-1]:
        place_market_order('BUY', self.ticker, 100, 100 * y_test[-1])

#example:
#apple = Strategy(Yahoo_data, 'AAPL')
#apple.svm_model_creation() (pywrapper.cpp:50)
2023-11-17T22:45:41.828 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.828 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.830 -0600 [            ] [py_runtime] INFO     - Running code:
import time
import numpy as np

class Strategy:
    def __init__(self) -> None:
        self.ticker = None
        self.holding = False
        self.last_action = None
        self.position = 0
        self.capital = 100000  # Initial capital
        self.short_window = 20
        self.long_window = 50
        self.price_history = []

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        if self.ticker == ticker:
            # Update position and capital based on trades
            if side == "BUY":
                self.position += quantity
                self.capital -= quantity * price
            elif side == "SELL":
                self.position -= quantity
                self.capital += quantity * price

    def on_orderbook_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        if self.ticker == ticker:
            # Update price history with the latest order book price
            self.price_history.append(price)
            if len(self.price_history) > self.long_window:
                self.price_history.pop(0)

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        if self.ticker == ticker:
            pass  # Implement your logic for reacting to account updates

    def moving_average_crossover_strategy(self) -> str:
        """
        Simple moving average crossover trading strategy.

        Returns:
        - str: Action to take ('BUY' or 'SELL')
        """
        if len(self.price_history) < self.long_window:
            return "HOLD"

        short_avg = np.mean(self.price_history[-self.short_window:])
        long_avg = np.mean(self.price_history[-self.long_window:])
        
        if short_avg > long_avg:
            return "BUY"
        else:
            return "SELL"

    def execute_strategy(self):
        while True:
            # Replace this with actual functions to get current and previous prices
            current_price = 100  # Simulated current price
            previous_price = 90  # Simulated previous price

            # Implement your trading strategy
            action = self.moving_average_crossover_strategy()

            # Place the market order based on your strategy
            if action == "BUY" and not self.holding:
                success = self.place_market_order("BUY", self.ticker, 10, current_price)
                if success:
                    self.holding = True
                    self.last_action = "BUY"
            elif action == "SELL" and self.holding:
                success = self.place_market_order("SELL", self.ticker, 10, current_price)
                if success:
                    self.holding = False
                    self.last_action = "SELL"

            # Sleep for a specific interval (e.g., 5 seconds) before the next iteration
            time.sleep(5)

    def place_market_order(self, side: str, ticker: str, quantity: float, price: float) -> bool:
        """Place a market order - DO NOT MODIFY"""
        # Implement your order placement logic here
        # For simplicity, assume the order is always successful
        print(f"Placed {side} order for {quantity} shares of {ticker} at ${price}")
        return True

# Initialize the strategy
strategy = Strategy()
strategy.ticker = "A"  # Set the ticker you want to trade

# Execute the strategy
strategy.execute_strategy()
 (pywrapper.cpp:50)
2023-11-17T22:45:41.831 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:41.831 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.046 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:42.046 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.046 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.065 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""
        while True:
            if place_market_order("BUY", "ETHUSD", 40, 1800):
                break
        self.prices = []
        self.ders = []

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        if ticker == "ETHUSD":
            self.prices.append(price)
        if len(self.prices) >= 1:
            self.ders = self.prices[-1] - self.prices[-2]
        if len(self.prices) > 1000:
            self.prices.pop(0)
        if len(self.ders) > 14:
            self.ders.pop(0)
            if (sum(self.ders))/len(self.ders) > .001:
                place_market_order("BUY", "ETHUSD", 10, 1800)
            elif (sum(self.ders))/len(self.ders) < -.001:
                place_market_order("SELL", "ETHUSD", 10, 1800)
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:42.065 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.065 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.070 -0600 [            ] [py_runtime] INFO     - Running code:
import numpy as np
import pandas as pd
import time


def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """


class Strategy:
    # MARKET_HORIZON: the number of recent trades considered relevant to future trades
    # ADX_HORIZON: the number of recent trades used to compute average directional index
    # EMPTY_INIT: empty array used to initialize dataframes
    # SMOOTH_HALF_LIFE: half life of smoothed change
    # trade_record: records the trades occured in the market based on MARKET_HORIZON
    # new_trade_count: count the number of trades occured after the last run
    # TRADE_COUNT_MIN: minimum new_trade_count required to place orders
    # tv_record: records the computed smoothed theoretical values
    # adx_record: records the computed ADX values
    # ADX_BOUND: minimum ADX required for a trend to be considered significant
    # thresh: array containing the buy [0][] and sell [1][] thresholds for A, B, C [][0,1,2]
    # a_owned, b_owned, c_owned: stocks owned

    MARKET_HORIZON = 50
    ADX_HORIZON = MARKET_HORIZON / 2  # Time horizon for evaluating ADX.
    ADX_BOUND = 20
    EMPTY_INIT = np.empty(MARKET_HORIZON)
    ALPHA = 0.4  # Damping factor used to smooth price changes.
    TRADE_COUNT_MIN = 8
    new_trade_count = 0

    # Records all trade occuring
    trade_record = pd.DataFrame(
        {
            "Price A": EMPTY_INIT,
            "Quantity A": EMPTY_INIT,
            "Price B": EMPTY_INIT,
            "Quantity B": EMPTY_INIT,
            "Price C": EMPTY_INIT,
            "Quantity C": EMPTY_INIT,
        }
    )

    # Record all stock theoretical value computed
    tv_record = pd.DataFrame(
        {
            "tv A": EMPTY_INIT,
            "tv B": EMPTY_INIT,
            "tv C": EMPTY_INIT,
        }
    )

    # Record all adx found
    adx_record = pd.DataFrame(
        {
            "adx A": EMPTY_INIT,
            "adx B": EMPTY_INIT,
            "adx C": EMPTY_INIT,
        }
    )

    thresh = np.empty((2, 3))
    a_owned = 0
    b_owned = 0
    c_owned = 0

    def __init__(self):
        MARKET_HORIZON = 50
        ADX_HORIZON = MARKET_HORIZON / 2  # Time horizon for evaluating ADX.
        ADX_BOUND = 20
        EMPTY_INIT = np.empty(MARKET_HORIZON)
        ALPHA = 0.4  # Damping factor used to smooth price changes.
        TRADE_COUNT_MIN = 8

        # Records all trade occuring
        trade_record = pd.DataFrame(
            {
                "Price A": EMPTY_INIT,
                "Quantity A": EMPTY_INIT,
                "Price B": EMPTY_INIT,
                "Quantity B": EMPTY_INIT,
                "Price C": EMPTY_INIT,
                "Quantity C": EMPTY_INIT,
            }
        )

        # Record all stock theoretical value computed
        tv_record = pd.DataFrame(
            {
                "tv A": EMPTY_INIT,
                "tv B": EMPTY_INIT,
                "tv C": EMPTY_INIT,
            }
        )

        # Record all adx found
        adx_record = pd.DataFrame(
            {
                "adx A": EMPTY_INIT,
                "adx B": EMPTY_INIT,
                "adx C": EMPTY_INIT,
            }
        )

        thresh = np.empty((2, 3))
        a_owned = 0
        b_owned = 0
        c_owned = 0
        new_trade_count = 0

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float):
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """

        # Print trade information
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

        # Update trade_record
        if ticker == "A":
            self.trade_record.iloc[1:-1, [0, 1]] = self.trade_record.iloc[0:-2, [0, 1]]
            self.trade_record.iloc[0, [0, 1]] = [price, quantity]
            self.new_trade_count += 1
        elif ticker == "B":
            self.trade_record.iloc[1:-1, [2, 3]] = self.trade_record.loc[0:-2, [2, 3]]
            self.trade_record.iloc[0, [2, 3]] = [price, quantity]
            self.new_trade_count += 1
        elif ticker == "C":
            self.trade_record.iloc[1:-1, [4, 5]] = self.trade_record.loc[0:-2, [4, 5]]
            self.trade_record.iloc[0, [4, 5]] = [price, quantity]
            self.new_trade_count += 1
        else:
            print("Trade occured, but record is not updated.")

        # Compute theoretical value
        current_tv = self.get_current_tv()

        # Update tv_record
        self.tv_record.iloc[1:-1, [0, 1]] = self.tv_record.iloc[0:-2, [0, 1]]
        self.tv_record.iloc[0, :] = current_tv

        # Compute ADX (based on current tv)
        current_adx = self.get_indicators()[0]

        # Update adx_record
        self.adx_record.iloc[1:-1, [0, 1]] = self.adx_record.iloc[0:-2, [0, 1]]
        self.adx_record.iloc[0, :] = current_adx

        # Generate decision thresholds in price
        self.thresh = self.generate_threshold(
            current_adx, self.get_indicators[1], self.get_indicators[2]
        )

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ):
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """

        # Place orders
        if (
            ticker == "A"
            and side == "BUY"
            and price >= self.thresh[0][0]
            and self.new_trade_count >= self.TRADE_COUNT_MIN
        ):
            order_status = place_market_order(
                side="SELL",
                ticker="A",
                quantity=min(self.a_owned, quantity),
                price=max(price, self.thresh[0][0]),
            )
        elif (
            ticker == "A"
            and side == "SELL"
            and price >= self.thresh[1][0]
            and self.new_trade_count >= self.TRADE_COUNT_MIN
        ):
            order_status = place_market_order(
                side="BUY",
                ticker="A",
                quantity=max(int(self.balance * 0.1 / price), quantity),
                price=min(price, self.thresh[0][0]),
            )
        if (
            ticker == "B"
            and side == "BUY"
            and price >= self.thresh[0][1]
            and self.new_trade_count >= self.TRADE_COUNT_MIN
        ):
            order_status = place_market_order(
                side="SELL",
                ticker="B",
                quantity=min(self.b_owned, quantity),
                price=max(price, self.thresh[0][0]),
            )
        elif (
            ticker == "B"
            and side == "SELL"
            and price >= self.thresh[1][1]
            and self.new_trade_count >= self.TRADE_COUNT_MIN
        ):
            order_status = place_market_order(
                side="BUY",
                ticker="B",
                quantity=max(int(self.balance * 0.1 / price), quantity),
                price=min(price, self.thresh[0][0]),
            )
        if (
            ticker == "C"
            and side == "BUY"
            and price >= self.thresh[0][2]
            and self.new_trade_count >= self.TRADE_COUNT_MIN
        ):
            order_status = place_market_order(
                side="SELL",
                ticker="C",
                quantity=min(self.c_owned, quantity),
                price=max(price, self.thresh[0][0]),
            )
        elif (
            ticker == "C"
            and side == "SELL"
            and price >= self.thresh[1][2]
            and self.new_trade_count >= self.TRADE_COUNT_MIN
        ):
            order_status = place_market_order(
                side="BUY",
                ticker="C",
                quantity=max(int(self.balance * 0.1 / price), quantity),
                price=min(price, self.thresh[0][0]),
            )

        # Handle order failure
        if order_status:
            print("Order successfully placed")
        else:
            print("Order placement failed")
            time.sleep(3)

        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ):
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """

        # Update stocks owned after order completion
        if side == "BUY":
            if ticker == "A":
                self.a_owned += quantity
            elif ticker == "B":
                self.b_owned += quantity
            elif ticker == "C":
                self.c_owned += quantity
        elif side == "SELL":
            if ticker == "A":
                self.a_owned -= quantity
            elif ticker == "B":
                self.b_owned -= quantity
            elif ticker == "C":
                self.c_owned -= quantity

        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )

    # Generate buy and sell signal based on TV and ADX
    def generate_threshold(self, adx, pos_DI, neg_DI):
        # Trading Strategy
        # Identify Bearish Pattern - sell
        thresholds = np.array([[float("inf"), float("inf"), float("inf")], [0, 0, 0]])
        if pos_DI > neg_DI and adx > 20:
            sell_min = self.tv_record.median() * np.exp(-adx / 40)
        # Identify Bullish Pattern - buy
        elif pos_DI < neg_DI and adx > 20:
            buy_max = self.tv_record.median() * np.exp(adx / 40 - 0.5)
        # No significant pattern - halt
        else:
            return np.array([[float("inf"), float("inf"), float("inf")], [0, 0, 0]])

        thresholds[0] = sell_min
        thresholds[1] = buy_max

        return thresholds

    # Get average directional index and current directional movement index
    def get_indicators(self):
        # Compute current and previous highs and lows based on smoothed tvs
        current_high = self.tv_record.iloc[0 : self.ADX_HORIZON, :].max()
        current_low = self.tv_record.iloc[0 : self.ADX_HORIZON, :].min()
        prev_high = self.tv_record.iloc[-self.ADX_HORIZON : -1, :].max()
        prev_low = self.tv_record.iloc[-self.ADX_HORIZON : -1, :].min()

        # Compute total range from previous and current TR
        # Previous & current are differentiated based on ADX_2023-11-17T22:45:42.080 -0600 [            ] [py_runtime] INFO     - Running code:
# you guys need better documentation... an example would've helped :( 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pandas_datareader as pdr
from datetime import datetime
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
import math


def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self, dataframe) -> None:
        """Your initialization code goes here."""
        self.data = dataframe

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: bool
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
    def Analysis(self):
        data = self.data
        data = data.filter(['Close'])
        dataset = data.values
        training_data_len = math.ceil(len(dataset)*0.8)
        scaler = MinMaxScaler(feature_range=(0,1), )
        scaled_data = scaler.fit_transform(dataset)
        train_data = scaled_data[0:training_data_len, :]
        x_train = []
        y_train = []
        for i in range(60, len(train_data)):
            x_train.append(train_data[i-60:i, 0])
            y_train.append(train_data[i, 0])
        if i <= 61:
            print(x_train)
            print(y_train)
        x_train, y_train = np.array(x_train), np.array(y_train)
        x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
        model = Sequential()
        model.add(LSTM(50, return_sequences=True, input_shape=(x_train.shape[1],x_train.shape[2],)))
        model.add(LSTM(50, return_sequences=False))
        model.add(Dense(25))
        model.add(Dense(25))
        model.add(Dense(25))
        model.add(Dense(25))
        model.add(Dense(1))
        model.compile(optimizer='adam', loss="mean_squared_error")
        model.fit(x_train, y_train, batch_size=1, epochs=1)
        test_data = scaled_data[training_data_len - 60:, :]
        x_test = []
        y_test = dataset[training_data_len:, :]
        for i in range(60, len(test_data)):
            x_test.append(test_data[i-60:i, 0])
            x_test = np.array(x_test)
        x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1))
        predictions = model.predict(x_test)
        predictions = scaler.inverse_transform(predictions)
        rmse = np.sqrt(np.mean(predictions - y_test)**2)
        return rmse 

     (pywrapper.cpp:50)
2023-11-17T22:45:42.081 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.081 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
HORIZON
        prev_TR = prev_high - prev_low
        current_TR = current_high - current_low
        adjusted_TR = self.ALPHA * current_TR + (1 - self.ALPHA) * prev_TR

        # Computer direction indices
        pos_DI = (current_high - prev_high) / adjusted_TR
        neg_DI = (prev_low - current_low) / adjusted_TR

        # Compute current directional index current_dx
        current_dx = (pos_DI - neg_DI).abs() / (pos_DI + neg_DI).abs()

        # Compute average directional movement index
        adjusted_adx = (
            self.ALPHA * current_dx + (1 - self.ALPHA) * self.adx_record.loc[0, :]
        )

        # Update adx_record
        self.adx_record.loc[1:-1, :] = self.adx_record.loc[0:-2, :]
        self.adx_record.loc[0, :] = adjusted_adx

        return np.array([adjusted_adx, pos_DI, neg_DI])

    # Get current theoretical value
    def get_current_tv(self):
        # Read records
        a_record = self.trade_record.filter(
            items=["Price", "Quantity"], like="A", axis=0
        )
        b_record = self.trade_record.filter(
            items=["Price", "Quantity"], like="B", axis=0
        )
        c_record = self.trade_record.filter(
            items=["Price", "Quantity"], like="C", axis=0
        )

        # Compute weighted average tv
        tv_a = self.weighted_avg(a_record.loc[:, "Price"], a_record.loc[:, "Quantity"])
        tv_b = self.weighted_avg(b_record.loc[:, "Price"], b_record.loc[:, "Quantity"])
        tv_c = self.weighted_avg(c_record.loc[:, "Price"], c_record.loc[:, "Quantity"])

        # Exponential smoothing by damping factor ALPHA=0.4
        tv_a = self.ALPHA * tv_a + (1 - self.ALPHA) * self.tv_record.iloc[0, 0]
        tv_b = self.ALPHA * tv_b + (1 - self.ALPHA) * self.tv_record.iloc[0, 1]
        tv_b = self.ALPHA * tv_c + (1 - self.ALPHA) * self.tv_record.iloc[0, 2]

        return np.array(tv_a, tv_b, tv_c)

    # Compute weighted average
    def weighted_avg(p, w):
        return np.sum(p * w) / np.sum(w)
 (pywrapper.cpp:50)
2023-11-17T22:45:42.073 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.073 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.213 -0600 [            ] [py_runtime] INFO     - Running code:
import threading
import pandas as pd
import math

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        volumes of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    #"""Template for a strategy."""

    def __init__(self) -> None:
        #"""Your initialization code goes here."""
        self.short_window = 5
        self.long_window = 20
        self.stock_info = {}
        self.money = 100000
        self.stop_event = threading.Event()
        
    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        #"""Called whenever two orders match. Could be one of your orders, or two other people's orders.

        #Parameters
        #----------
        #ticker
        #    Ticker of orders that were matched ("A", "B", or "C")
        #side 
        #    Side of orders that were matched ("BUY" or "SELL")
        #price
        #    Price that trade was executed at
        #quantity
        #    volumes traded
        #"""
        awaiting_trade = threading.Thread(target = self.submit_order, args = (ticker, side, price, quantity))
        awaiting_trade.start()

        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

        
    def submit_order(self, ticker: str, side: str, price: float, quantity: float) -> None: 
        if ticker not in self.stock_info:
            self.stock_info[ticker] = {"volumes" :pd.DataFrame(columns = ["price", "quantity", "volume"]), "position" : False, "quantity": 0}

        self.stock_info[ticker]["volumes"] = pd.concat([self.stock_info[ticker]["volumes"], pd.DataFrame({"price" : [price], "quantity": [quantity], "volume": [price*quantity]})])
        self.stock_info[ticker]["volumes"] = self.stock_info[ticker]["volumes"].tail(self.long_window)

        if len(self.stock_info[ticker]["volumes"]) >= self.long_window:
            short_ma = self.stock_info[ticker]["volumes"]["price"].rolling(window = self.short_window).mean().iloc[-1]
            long_ma = self.stock_info[ticker]["volumes"]["price"].rolling(window = self.long_window).mean().iloc[-1]
            short_ma_volume = self.stock_info[ticker]["volumes"]["volume"].rolling(window = self.short_window).sum().iloc[-1]/self.stock_info[ticker]["volumes"]["quantity"].rolling(window = self.short_window).sum().iloc[-1]
            long_ma_volume = self.stock_info[ticker]["volumes"]["volume"].rolling(window = self.short_window).sum().iloc[-1]/self.stock_info[ticker]["volumes"]["quantity"].rolling(window = self.short_window).sum().iloc[-1]

            if (short_ma_volume > long_ma_volume or short_ma > long_ma) and self.money > 0:
                success = place_market_order("BUY", ticker, quantity/100 if price*quantity/100 < self.money else math.trunc(price/self.money) , price)
                if success:
                    self.stop_event.wait()
                    self.stock_info[ticker]["quantity"] += quantity/100
                    self.money -= price*quantity/100
                    self.stock_info[ticker]["position"] = True
                    print(f"BUY {quantity/100} of {ticker} at {price}")
                    self.stop_event.clear()
                else:
                    print("Failed to place BUY order")
            elif (short_ma_volume < long_ma_volume or short_ma < long_ma ) and self.stock_info[ticker]["position"] == True:
                success = place_market_order("SELL" , ticker, self.stock_info[ticker]["quantity"], price)
                if success:
                    self.stop_event.wait()
                    self.stock_info[ticker]["quantity"] = 0
                    self.stock_info[ticker]["position"] = False
                    self.money += price * self.stock_info[ticker]["quantity"]
                    print(f"SELL all of {ticker} at {price}")
                    self.stop_event.clear()
                else:
                    print("Failed to place SELL order")


    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        #"""Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        #Parameters
        #----------
        #ticker
        #    Ticker that has an orderbook update ("A", "B", or "C")
        #side
        #    Which orderbook was updated ("BUY" or "SELL")
        #price
        #    Price of orderbook that has an update
        #quantity
        #    volumes placed into orderbook
        #"""
        

        

        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        #"""Called whenever one of your orders is filled.

        #Parameters
        #----------
        #ticker
        #    Ticker of order that was fulfilled ("A", "B", or "C")
        #side
        #    Side of order that was fulfilled ("BUY" or "SELL")
        #price
        #    Price that order was fulfilled at
        #quantity
        #    volumes of order that was fulfilled
        #capital_remaining
        #    Ammount of capital after fulfilling order
        #"""

        self.stop_event.set()

        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:42.218 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.218 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.236 -0600 [            ] [py_runtime] INFO     - Running code:
import time
import random

# Constants for rate limiting
RATE_LIMIT_PER_MINUTE = 30
RATE_LIMIT_RESET_INTERVAL = 60  # 60 seconds in a minute

# Variables to track rate limiting
last_order_timestamp = 0
order_count = 0

#This is a placeholder function for a function to place order
def simulate_order_placement(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Simulated function to place an order."""
    # Simulate order placement with a success rate of 80%
    success_rate = 0.8
    order_succeeded = random.random() < success_rate

    if order_succeeded:
        print(f"Placed {side} order for {quantity} {ticker} at ${price} per unit.")
        return True
    else:
        print(f"Failed to place {side} order for {quantity} {ticker} at ${price} per unit (simulated error).")
        return False

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

    global last_order_timestamp, order_count

    # Check if the rate limit has been reached within the current minute
    current_timestamp = int(time.time())
    if current_timestamp - last_order_timestamp >= RATE_LIMIT_RESET_INTERVAL:
        # Reset the rate limit count at the start of a new minute
        order_count = 0
        last_order_timestamp = current_timestamp

    # Check if the rate limit has been exceeded
    if order_count >= RATE_LIMIT_PER_MINUTE:
        # Rate limit exceeded, wait for the next minute to reset the rate limit
        wait_time = RATE_LIMIT_RESET_INTERVAL - (current_timestamp - last_order_timestamp)
        print(f"Rate limit reached. Waiting for {wait_time} seconds before retrying.")
        time.sleep(wait_time)

        # Reset the rate limit count and timestamp
        order_count = 0
        last_order_timestamp = current_timestamp

    # Increment the order count for the current minute
    order_count += 1

    # Implement the logic to place a market order here

    # Replace the following line with the actual code to place the order with your API
    response = simulate_order_placement(side, ticker, quantity, price)

    # Process the response and return True if the order succeeded, False otherwise
    if response:  # Assuming a successful response code
        return True
    else:
        return False

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here.
        determine market price"""
        self.position = None  # Initialize position attribute to None
        self.last_trade_price = None  # Initialize last trade price attribute to None

        

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

         # Update the last trade price
        self.last_trade_price = price

        # momentum strategy
        if self.position is None:
            # If not in a position, look for an opportunity to enter a position
            if side == "BUY" and price > self.last_trade_price:
                self.place_market_order("BUY", ticker, quantity, price)
                self.position = "LONG"
            elif side == "SELL" and price < self.last_trade_price:
                self.place_market_order("SELL", ticker, quantity, price)
                self.position = "SHORT"
        else:
            # If already in a position, look for an opportunity to exit
            if (
                (self.position == "LONG" and side == "SELL")
                or (self.position == "SHORT" and side == "BUY")
            ):
                self.place_market_order("SELL", ticker, quantity, price)
                self.position = None

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: bool
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")
        
        if self.position is not None:
            # You are in a position, so you can monitor the order book for exit signals
            if (
                (self.position == "LONG" and side == "SELL")
                or (self.position == "SHORT" and side == "BUY")
            ):
                # Implement exit logic based on order book data
                price_increase_ratio = price / self.last_trade_price
                
                # Check if the price increase is significant (e.g., at least 20%)
                if price_increase_ratio >= 1.2:
                    # Increase the quantity to sell
                    new_quantity = quantity * 1.5  # Increase quantity by 50%
                    self.place_market_order("SELL", ticker, new_quantity, price)
                else:
                    # Implement other exit logic if needed
                    self.place_market_order("SELL", ticker, quantity, price)
                self.position = None

            # If you are buying and the price is much lower than the last trade price, adjust your strategy
            elif (
                (self.position == "LONG" and side == "BUY")
                and price < 0.9 * self.last_trade_price  # Example threshold (adjust as needed)
            ):
                # Implement adjustment logic for buying
                self.place_market_order("BUY", ticker, quantity * 2, price)  # Double the quantity

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
        if self.position is not None:
            # Check if the filled order corresponds to your open position
            if (
                (self.position == "LONG" and side == "BUY")
                or (self.position == "SHORT" and side == "SELL")
            ):
                # Calculate profit/loss based on the order's filled price
                profit_or_loss = (price - self.entry_price) * quantity

                if profit_or_loss > 0:
                    print(f"Profit: {profit_or_loss}")
                    # Implement profit-taking logic or exit strategy here

                elif profit_or_loss < 0:
                    print(f"Loss: {profit_or_loss}")
                    # Implement stop-loss logic or exit strategy here

                else:
                    print("No profit or loss.")
                
                # Reset your position and related variables
                self.position = None
                self.entry_price = None
 (pywrapper.cpp:50)
2023-11-17T22:45:42.248 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.248 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.263 -0600 [            ] [py_runtime] INFO     - Running code:

import bisect
import time
import threading
from typing import Optional

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """
"""
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    print(side, ticker, quantity, price)
"""
class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""
        self.USD = 100000
        self.USD_A = 33300
        self.USD_B = 33300
        self.USD_C = 33300
        self.A = 0
        self.B = 0
        self.C = 0
        self.depth_multiplier = 5
        self.A_book = OrderBook()
        self.B_book = OrderBook()
        self.C_book = OrderBook()
        self.current_order_count = 0

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        price = round(price, 10)
        quantity = round(quantity, 10)

        if ticker == 'A':
            response = self.A_book.process_trade(side, price, quantity)
            try:
                if response == True:
                    if self.A > 0:
                        price_to_sell, min_price = self.A_book.get_bid_depth(self.A)
                        bid_depth_price, _ = self.A_book.get_bid_depth(self.A * self.depth_multiplier)#, self.A)
                        ask_depth_price, _ = self.A_book.get_ask_depth(self.A * self.depth_multiplier)
                        if ask_depth_price != None and bid_depth_price != None and price_to_sell != None:
                            if (ask_depth_price + bid_depth_price)/2 < price_to_sell:
                                place_market_order("SELL", "A", self.A , min_price)

                    if self.USD_A > 10:
                        quantity_to_buy, avg_price_buy, max_price = self.A_book.get_ask_depth_usd(self.USD_A)
                        if quantity_to_buy != None:
                            bid_depth_price, _ = self.A_book.get_bid_depth(quantity_to_buy * self.depth_multiplier)
                            ask_depth_price, _ = self.A_book.get_ask_depth(quantity_to_buy * self.depth_multiplier)#, quantity_to_buy)

                            if ask_depth_price != None and bid_depth_price != None:
                                #print(ask_depth_price, bid_depth_price, avg_price_buy)
                                if (ask_depth_price + bid_depth_price)/2 > avg_price_buy:
                                    place_market_order("BUY", "A", quantity_to_buy, max_price)    
            except Exception as e:
                print(e)
        elif ticker == 'B':
            response = self.B_book.process_trade(side, price, quantity)
            try:
                if response == True:
                    if self.B > 0:
                        price_to_sell, min_price = self.B_book.get_bid_depth(self.B)
                        bid_depth_price, _ = self.B_book.get_bid_depth(self.B * self.depth_multiplier)#, self.B)
                        ask_depth_price, _ = self.B_book.get_ask_depth(self.B * self.depth_multiplier)
                        if ask_depth_price != None and bid_depth_price != None:
                            if (ask_depth_price + bid_depth_price)/2 < price_to_sell:
                                place_market_order("SELL", "B", self.B , min_price)

                    if self.USD_B > 10:
                        quantity_to_buy, avg_price_buy, max_price = self.B_book.get_ask_depth_usd(self.USD_B)
                        if quantity_to_buy != None:
                            bid_depth_price, _ = self.B_book.get_bid_depth(quantity_to_buy * self.depth_multiplier)
                            ask_depth_price, _ = self.B_book.get_ask_depth(quantity_to_buy * self.depth_multiplier)#, quantity_to_buy)

                            if ask_depth_price != None and bid_depth_price != None:
                                #print(ask_depth_price, bid_depth_price, avg_price_buy)
                                if (ask_depth_price + bid_depth_price)/2 > avg_price_buy:
                                    place_market_order("BUY", "B", quantity_to_buy, max_price)    
            except Exception as e:
                print(e)
        elif ticker == 'C':
            response = self.C_book.process_trade(side, price, quantity)
            try:
                if response == True:
                    if self.C > 0:
                        price_to_sell, min_price = self.C_book.get_bid_depth(self.C)
                        bid_depth_price, _ = self.C_book.get_bid_depth(self.C * self.depth_multiplier)#, self.C)
                        ask_depth_price, _ = self.C_book.get_ask_depth(self.C * self.depth_multiplier)
                        if ask_depth_price != None and bid_depth_price != None:
                            if (ask_depth_price + bid_depth_price)/2 < price_to_sell:
                                place_market_order("SELL", "C", self.C , min_price)

                    if self.USD_C > 10:
                        quantity_to_buy, avg_price_buy, max_price = self.C_book.get_ask_depth_usd(self.USD_C)
                        if quantity_to_buy != None:
                            bid_depth_price, _ = self.C_book.get_bid_depth(quantity_to_buy * self.depth_multiplier)
                            ask_depth_price, _ = self.C_book.get_ask_depth(quantity_to_buy * self.depth_multiplier)#, quantity_to_buy)

                            if ask_depth_price != None and bid_depth_price != None:
                                #print(ask_depth_price, bid_depth_price, avg_price_buy)
                                if (ask_depth_price + bid_depth_price)/2 > avg_price_buy:
                                    place_market_order("BUY", "C", quantity_to_buy, max_price)    
            except Exception as e:
                print(e)
        #print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        price = round(price, 10)
        quantity = round(quantity, 10)
        
        if ticker == 'A':
            response = self.A_book.process_update(side, price, quantity)
            try:
                if response == True:
                    if self.A > 0:
                        price_to_sell, min_price = self.A_book.get_bid_depth(self.A)
                        bid_depth_price, _ = self.A_book.get_bid_depth(self.A * self.depth_multiplier)#, self.A)
                        ask_depth_price, _ = self.A_book.get_ask_depth(self.A * self.depth_multiplier)
                        if ask_depth_price != None and bid_depth_price != None and price_to_sell != None:
                            if (ask_depth_price + bid_depth_price)/2 < price_to_sell:
                                place_market_order("SELL", "A", self.A , min_price)

                    if self.USD_A > 10:
                        quantity_to_buy, avg_price_buy, max_price = self.A_book.get_ask_depth_usd(self.USD_A)
                        if quantity_to_buy != None:
                            bid_depth_price, _ = self.A_book.get_bid_depth(quantity_to_buy * self.depth_multiplier)
                            ask_depth_price, _ = self.A_book.get_ask_depth(quantity_to_buy * self.depth_multiplier)#, quantity_to_buy)

                            if ask_depth_price != None and bid_depth_price != None:
                                #print(ask_depth_price, bid_depth_price, avg_price_buy)
                                if (ask_depth_price + bid_depth_price)/2 > avg_price_buy:
                                    place_market_order("BUY", "A", quantity_to_buy, max_price)    
            except Exception as e:
                print(e)
        elif ticker == 'B':
            response = self.B_book.process_update(side, price, quantity)
            try:
                if response == True:
                    if self.B > 0:
                        price_to_sell, min_price = self.B_book.get_bid_depth(self.B)
                        bid_depth_price, _ = self.B_book.get_bid_depth(self.B * self.depth_multiplier)#, self.B)
                        ask_depth_price, _ = self.B_book.get_ask_depth(self.B * self.depth_multiplier)
                        if ask_depth_price != None and bid_depth_price != None:
                            if (ask_depth_price + bid_depth_price)/2 < price_to_sell:
                                place_market_order("SELL", "B", self.B , min_price)

                    if self.USD_B > 10:
                        quantity_to_buy, avg_price_buy, max_price = self.B_book.get_ask_depth_usd(self.USD_B)
                        if quantity_to_buy != None:
                            bid_depth_price, _ = self.B_book.get_bid_depth(quantity_to_buy * self.depth_multiplier)
                            ask_depth_price, _ = self.B_book.get_ask_depth(quantity_to_buy * self.depth_multiplier)#, quantity_to_buy)

                            if ask_depth_price != None and bid_depth_price != None:
                                #print(ask_depth_price, bid_depth_price, avg_price_buy)
                                if (ask_depth_price + bid_depth_price)/2 > avg_price_buy:
                                    place_market_order("BUY", "B", quantity_to_buy, max_price)    
            except Exception as e:
                print(e)
        elif ticker == 'C':
            response = self.C_book.process_update(side, price, quantity)
            try:
                if response == True:
                    if self.C > 0:
                        price_to_sell, min_price = self.C_book.get_bid_depth(self.C)
                        bid_depth_price, _ = self.C_book.get_bid_depth(self.C * self.depth_multiplier)#, self.C)
                        ask_depth_price, _ = self.C_book.get_ask_depth(self.C * self.depth_multiplier)
                        if ask_depth_price != None and bid_depth_price != None:
                            if (ask_depth_price + bid_depth_price)/2 < price_to_sell:
                                place_market_order("SELL", "C", self.C , min_price)

                    if self.USD_C > 10:
                        quantity_to_buy, avg_price_buy, max_price = self.C_book.get_ask_depth_usd(self.USD_C)
                        #print(self.C_book.get_ask_depth_usd(self.USD_C))
                        if quantity_to_buy != None:
                            bid_depth_price, _ = self.C_book.get_bid_depth(quantity_to_buy * self.depth_multiplier)
                            ask_depth_price, _ = self.C_book.get_ask_depth(quantity_to_buy * self.depth_multiplier)#, quantity_to_buy)

                            if ask_depth_price != None and bid_depth_price != None:
                                #print(ask_depth_price, bid_depth_price, avg_price_buy)
                                if (ask_depth_price + bid_depth_price)/2 > avg_price_buy:
                                    place_market_order("BUY", "C", quantity_to_buy, max_price)    
            except Exception as e:
                print(e)
        #print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        self.USD = capital_remaining
        asset_change = 0
        usd_change = 0
        if side == "BUY":
            asset_change = quantity
            usd_change = -price*quantity
        elif side == "SELL":
            asset_change = -quantity
            usd_change = price*quantity

        if ticker == "A":
            self.A = self.A + asset_change
            self.USD_A = self.USD_A + usd_change
        elif ticker == "B":
            self.B = self.B + asset_change
            self.USD_B = self.USD_B + usd_change
        elif ticker == "C":
            self.C = self.C + asset_change
            self.USD_C = self.USD_C + usd_change


        #print(f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}")



class OrderBook():
    
    def __init__(self) -> None:
        """
        Bids and ask variables contain price as the key
        Values are 2 element arrays: [price, quantity]
        """

        self.bids = {}
        self.bids_keys = []
        self.cached_bids = {'updates': [],
                            'trades' : []}
        self.asks = {}
        self.asks_keys = []
        self.cached_asks = {'updates': [],
                            'trades' : []}

        
        self.cache_time = 3 #Number of seconds till cached updates are treaded as positive additions to book

        self.lock = threading.Lock()  # A lock for thread-safe updates
        self.running = True
        self.checker_thread = threading.Thread(target=self.check_old_unmatched_updates)
        self.checker_thread.start()


    def check_old_unmatched_updates(self) -> None:
        while self.running:
            current_time = time.time()
            with self.lock:
                # Check cached bids
                for cached_bid in self.cached_bids['updates']:
                    print("Checking")
                    if current_time - cached_bid['timestamp'] > self.cache_time:  # Older than 1 second
                        self.bids[cached_bid['price']][1] = self.bids[cached_bid['price']][1] + cached_bid['quantity']
                        self.cached_bids['updates'].remove(cached_bid)
                
                # Check cached asks
                for cached_ask in self.cached_asks['updates']:
                    if current_time - cached_ask['timestamp'] > self.cache_time:  # Older than 1 second
                        self.asks[cached_ask['price']][1] = self.asks[cached_ask['price']][1] + cached_ask['quantity']
                        self.cached_asks['updates'].remove(cached_ask)

            time.sleep(0.5) 

    def process_update(self, side, price, quantity) -> bool:
        response = False
        if side == 'BUY':
            response = self.change_bid(price, quantity)
        elif side == 'SELL':
            response = self.change_ask(price, quantity)

        return response

    def process_trade(self, side, price, quantity) -> bool:
        # SELL corresponds to a bid update, BUY corresponds to an ask update
        with self.lock:
            if side == 'SELL':
                found = False
                if len(self.cached_bids['updates']) > 0:
                    for cached_bid in self.cached_bids['updates']:
                        if cached_bid['price'] == price and cached_bid['quantity'] == quantity:
                            #This means that the bid was decreased as the result of a trade
                            if self.bids[price][1] - quantity <= 0:
                                del self.bids[price]
                                self.bids_keys.remove(price)
                            else:
                                self.bids[price][1] = self.bids[price][1] - quantity
                            self.cached_bids['updates'].remove(cached_bid)
                            found = True
                            return True
                            break
                if not found:
                    new_cached_bid =  {
                        'price' : price,
                        'quantity' : quantity,
                        'timestamp' : time.time()
                    }
                    self.cached_bids['trades'].append(new_cached_bid)
                    return False
            elif side == 'BUY':
                found = False
                if len(self.cached_asks['updates']) > 0:
                    for cached_ask in self.cached_asks['updates']:
                        if cached_ask['price'] == price and cached_ask['quantity'] == quantity:
                            #This means that the bid was decreased as the result of a trade
                            if self.asks[price][1] - quantity <= 0:
                                del self.asks[price]
                                self.asks_keys.remove(price)
                            else:
                                self.asks[price][1] = self.asks[price][1] - quantity
                            self.cached_asks['updates'].remove(cached_ask)
                            found = True
                            return True
                            break
                if not found:
                    new_cached_ask =  {
                        'price' : price,
                        'quantity' : quantity,
                        'timestamp' : time.time()
                    }
                    self.cached_asks['trades'].append(new_cached_ask)
                    return False


    def change_bid(self, price, quantity) -> bool:
        with self.lock:
            if price in self.bids:
                # This needs to cache the update --> when cached, it should either match with a trade that has 
                # also been cached, or it should wait for a certain amount of time and then just add the amount
                # to the orderbook
                found = False
                if len(self.cached_bids['trades']) > 0:
                    for cached_bid in self.cached_bids['trades']:
                        if cached_bid['price'] == price and cached_bid['quantity'] == quantity:
                            #This means that the bid was decreased as the result of a trade
                            if self.bids[price][1] - quantity <= 0:
                                del self.bids[price]
                                self.bids_keys.remove(price)
                            else:
                                self.bids[price][1] = self.bids[price][1] - quantity
                            self.cached_bids['trades'].remove(cached_bid)
                            found = True
                            return True
                            break
                if not found:
                    new_cached_bid =  {
                        'price' : price,
                        'quantity' : quantity,
                        'timestamp' : time.time()
                    }
                    self.cached_bids['updates'].append(new_cached_bid)
                    return False
            else:
                self.bids[price] = [price, quantity]
                bisect.insort_left(self.bids_keys, price)
                self.bids_keys = self.bids_keys[::-1]
                return True


    def change_ask(self, price, quantity) -> bool:
        with self.lock:
            if price in self.asks:
                found = False
                if len(self.cached_asks['trades']) > 0:
                    for cached_ask in self.cached_asks['trades']:
                        if cached_ask['price'] == price and cached_ask['quantity'] == quantity:
                            #This means that the bid was decreased as the result of a trade
                            if self.asks[price][1] - quantity <= 0:
                                del self.asks[price]
                                self.asks_keys.remove(price)
                            else:
                                self.asks[price][1] = self.asks[price][1] - quantity
                            self.cached_asks['trades'].remove(cached_ask)
                            found = True
                            return True
                            break
                if not found:
                    new_cached_ask =  {
                        'price' : price,
                        'quantity' : quantity,
                        'timestamp' : time.time()
                    }
                    self.cached_asks['updates'].append(new_cached_ask)
                    return False
            else:
                self.asks[price] = [price, quantity]
                bisect.insort_left(self.asks_keys, price)
                return True


    def get_bid_depth(self, volume_target, ignore_amount = 0) -> Optional[float]:
        """
        calculates the weighted average of the price if you were to sell volume_target, if you are 
        """
        accrued_volume = 0
        accrued_volume_usd = 0
        price = None
        for bid_price in self.bids_keys:
            price = bid_price
            volume = self.bids[bid_price][1]

            # Skip/ignore the desired volume
            if accrued_volume < ignore_amount:
                ignore_vol = min(volume, ignore_amount - accrued_volume)
                volume -= ignore_vol
                accrued_volume += ignore_vol

            # If the bid's volume can be entirely consumed
            if accrued_volume + volume <= volume_target + ignore_amount:
                accrued_volume_usd += volume * price
                accrued_volume += volume
            # If only part of the bid's volume is needed
            else:
                needed_volume = volume_target + ignore_amount- accrued_volume
                accrued_volume_usd += needed_volume * price
                accrued_volume += needed_volume

            # If we've reached the target volume, break
            if accrued_volume >= volume_target + ignore_amount:
                break

        accrued_volume -= ignore_amount
        # If there's not enough volume
        if accrued_volume < volume_target:
            return None, None

        # Return the weighted average price
        return accrued_volume_usd / accrued_volume , price

    def get_ask_depth_usd(self, usd_target):
        accrued_volume = 0
        accrued_volume_usd = 0
        price = None
        for ask_price in self.asks_keys:  # Iterate over asks from lowest price to highest
            price = ask_price
            volume = self.asks[ask_price][1]
            usd_volume = price*volume

            if usd_volume + accrued_volume_usd > usd_target:
                #maxed out:
                usd_left = usd_target - accrued_volume_usd
                vol_to_add = volume * (usd_left / usd_volume)
                accrued_volume += vol_to_add
                accrued_volume_usd += usd_left
                break
            else:
                accrued_volume += volume
                accrued_volume_usd += usd_volume

        if accrued_volume_usd < usd_target:
            return None, None, None

        return accrued_volume, usd_target / accrued_volume, price

    def get_ask_depth(self, volume_target, ignore_amount=0) -> Optional[float]:
        """
        Calculates the weighted average of the price if you were to buy volume_target, 
        after ignoring the specified ignore_amount. Returns None if there's not enough volume.
        """
        accrued_volume = 0
        accrued_volume_usd = 0
        price = None
        for ask_price in self.asks_keys:  # Iterate over asks from lowest price to highest
            price = ask_price
            volume = self.asks[ask_price][1]

            # Skip/ignore the desired volume
            if accrued_volume < ignore_amount:
                ignore_vol = min(volume, ignore_amount - accrued_volume)
                volume -= ignore_vol
                accrued_volume += ignore_vol

            # If the ask's volume can be entirely consumed
            if accrued_volume + volume <= volume_target + ignore_amount:
                accrued_volume_usd += volume * price
                accrued_volume += volume
            # If only part of the ask's volume is needed
            else:
                needed_volume = volume_target + ignore_amount - accrued_volume
                accrued_volume_usd += needed_volume * price
                accrued_volume += needed_volume

            # If we've reached the target volume, break
            if accrued_volume >= volume_target+ ignore_amount:
                break

        accrued_volume -= ignore_amount

        # If there's not enough volume
        if accrued_volume < volume_target:
            return None, None

        # Return the weighted average price
        return accrued_volume_usd / accrued_volume, price

    def stop(self):
        """Method to stop the checker thread"""
        self.running = False
        self.checker_thread.join() (pywrapper.cpp:50)
2023-11-17T22:45:42.276 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.276 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.363 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""
        # Initialize starting capital
        self.starting_capital = 100000
        # Define the list of tickers to trade
        self.tickers = ["A", "B", "C"]
        # Calculate the amount of capital to allocate for each stock
        self.capital_per_ticker = self.starting_capital / len(self.tickers)
        # Initialize a dictionary to keep track of the quantity of each stock held
        self.holdings = {ticker: 0 for ticker in self.tickers}

    def buy_equal_amount_of_stocks(self, side: str, ticker: str, quantity: float, price: float):
        # Buy an equal amount of each stock with available capital
        for ticker in self.tickers:
            # Calculate the quantity of each stock to buy
            quantity_to_buy = self.capital_per_ticker / price  # Assuming price is known
            if self.place_market_order("BUY", ticker, quantity_to_buy, price):
                self.holdings[ticker] += quantity_to_buy

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        if side == "BUY":
            self.holdings[ticker] += quantity
        elif side == "SELL":
            self.holdings[ticker] -= quantity
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:42.364 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.364 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.351 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side, ticker, quantity, price):
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """
    print(side, ticker, quantity, price)


class Strategy:

    def __init__(self):
        self.times = 0
        self.holdings = {"A": 0, "B": 0, "C": 0}
        self.funds = 100000
        self.ABuy = {}
        self.ASell = {}
        self.ATrades = {}
        self.AVWAP = []
        self.APrices = []
        self.BBuy = {}
        self.BSell = {}
        self.BTrades = {}
        self.BVWAP = []
        self.BPrices = []
        self.CBuy = {}
        self.CSell = {}
        self.CTrades = {}
        self.CVWAP = []
        self.CPrices = []

    def update_data(self, ticker, side, price, quantity):
        if side == "BUY":
            if ticker == "A":
                if price in self.ABuy:
                    self.ABuy[price] += quantity
                else:
                    self.ABuy[price] = quantity
            elif ticker == "B":
                if price in self.BBuy:
                    self.BBuy[price] += quantity
                else:
                    self.BBuy[price] = quantity
            else:
                if price in self.CBuy:
                    self.CBuy[price] += quantity
                else:
                    self.CBuy[price] = quantity
        else:
            if ticker == "A":
                if price in self.ASell:
                    self.ASell[price] += quantity
                else:
                    self.ASell[price] = quantity
            elif ticker == "B":
                if price in self.BSell:
                    self.BSell[price] += quantity
                else:
                    self.BSell[price] = quantity
            else:
                if price in self.CSell:
                    self.CSell[price] += quantity
                else:
                    self.CSell[price] = quantity

    def update_VWAP(self, ticker):
        cumulative_volume = 0
        cumulative_price_volume = 0

        if ticker == "A":
            if self.ATrades == {}:
                return
            for price, volume in zip(list(self.ATrades.keys()), list(self.ATrades.values())):
                cumulative_volume += volume
                cumulative_price_volume += price * volume

            self.AVWAP.append(cumulative_price_volume / cumulative_volume)
            if len(self.AVWAP) > 50:
                self.AVWAP = self.AVWAP[-50:]

        elif ticker == "B":
            if self.BTrades == {}:
                return
            for price, volume in zip(list(self.BTrades.keys()), list(self.BTrades.values())):
                cumulative_volume += volume
                cumulative_price_volume += price * volume

            self.BVWAP.append(cumulative_price_volume / cumulative_volume)
            if len(self.BVWAP) > 50:
                self.BVWAP = self.BVWAP[-50:]

        else:
            if self.CTrades == {}:
                return
            for price, volume in zip(list(self.CTrades.keys()), list(self.CTrades.values())):
                cumulative_volume += volume
                cumulative_price_volume += price * volume

            self.CVWAP.append(cumulative_price_volume / cumulative_volume)
            if len(self.CVWAP) > 50:
                self.CVWAP = self.CVWAP[-50:]

    def update_price(self, ticker):
        if ticker == "A":
            if self.ABuy == {} or self.ASell == {}:
                return
            self.APrices.append((min(list(self.ASell.keys())) + max(list(self.ABuy.keys())))/2)
            if len(self.APrices) > 50:
                self.APrices = self.APrices[-50:]
        elif ticker == "B":
            if self.BBuy == {} or self.BSell == {}:
                return
            self.BPrices.append((min(list(self.BSell.keys())) + max(list(self.BBuy.keys()))) / 2)
        else:
            if self.CBuy == {} or self.CSell == {}:
                return
            self.APrices.append((min(list(self.CSell.keys())) + max(list(self.CBuy.keys()))) / 2)

    def update_trades(self, ticker, price, quantity):
        if ticker == "A":
            if price in self.ATrades:
                self.ATrades[price] += quantity
            else:
                self.ATrades[price] = quantity
        if ticker == "B":
            if price in self.BTrades:
                self.BTrades[price] += quantity
            else:
                self.BTrades[price] = quantity

        else:
            if price in self.CTrades:
                self.CTrades[price] += quantity
            else:
                self.CTrades[price] = quantity

    def decision(self, ticker, limit):
        if ticker == "A":
            if self.ASell != {} and self.holdings["A"] == 0:
                place_market_order("BUY", "A", limit//min(list(self.ASell.keys())), min(list(self.ASell.keys())))
            if len(self.AVWAP) == 0 or len(self.APrices) < 2:
                return
            if self.AVWAP[-1] < self.APrices[-2] < self.APrices[-1]:
                place_market_order("SELL", "A", self.holdings["A"], self.APrices[-2])
            elif self.AVWAP[-1] > self.APrices[-2] > self.APrices[-1]:
                place_market_order("BUY", "A", limit // self.APrices[-1], self.APrices[-1])
            else:
                return

        elif ticker == "B":
            if self.BSell != {} and self.holdings["B"] == 0:
                place_market_order("BUY", "B", limit // min(list(self.BSell.keys())), min(list(self.BSell.keys())))
            if len(self.BVWAP) == 0 or len(self.BPrices) < 2:
                return
            if self.BVWAP[-1] < self.BPrices[-2] < self.BPrices[-1]:
                place_market_order("SELL", "B", self.holdings["B"], self.BPrices[-2])
            elif self.BVWAP[-1] > self.BPrices[-2] > self.BPrices[-1]:
                place_market_order("BUY", "B", limit // self.BPrices[-1], self.BPrices[-1])
            else:
                return

        else:
            if self.CSell != {} and self.holdings["C"] == 0:
                place_market_order("BUY", "C", limit // min(list(self.CSell.keys())), min(list(self.CSell.keys())))
            if len(self.CVWAP) == 0 or len(self.CPrices) < 2:
                return
            if self.CSell != {} and self.holdings["C"] == 0:
                place_market_order("BUY", "C", min(list(self.CSell.keys())))
                return
            if self.CVWAP[-1] < self.CPrices[-2] < self.CPrices[-1]:
                place_market_order("SELL", "C", self.holdings["C"], self.CPrices[-2])
            elif self.CVWAP[-1] > self.CPrices[-2] > self.CPrices[-1]:
                place_market_order("BUY", "C", limit // self.CPrices[-1], self.CPrices[-1])
            else:
                return

    def on_trade_update(self, ticker: str, side, price, quantity):
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        self.times += 1
        self.update_price(ticker)
        self.update_trades(ticker, price, quantity)
        self.decision(ticker, self.funds // 3)

    def on_orderbook_update(self, ticker, side, price, quantity):
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        self.times += 1
        self.update_data(ticker, side, price, quantity)
        self.update_VWAP(ticker)
        self.update_price(ticker)
        self.decision(ticker, self.funds // 3)

    def on_account_update(self, ticker, side, price, quantity, capital_remaining):
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        self.funds = capital_remaining - 10000
        if side == "BUY":
            if ticker == "A":
                self.holdings["A"] += quantity
            elif ticker == "B":
                self.holdings["B"] += quantity
            else:
                self.holdings["C"] += quantity
        else:
            if ticker == "A":
                self.holdings["A"] -= quantity
            elif ticker == "B":
                self.holdings["B"] -= quantity
            else:
                self.holdings["C"] -= quantity









 (pywrapper.cpp:50)
2023-11-17T22:45:42.354 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.354 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.380 -0600 [            ] [py_runtime] INFO     - Running code:
import numpy
# import torch
import scipy
import pandas
# import polars
# import scipy
# import scikit-learn

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> None:
    """Place a market order - DO NOT MODIFY"""

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""
        print("TESTING")
        print(numpy.__version__)
        while(True):
            print("Test")

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched
        side

        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")
        if(ticker == "A" or ticker=="B" or ticker=="C"):
            return
        test = []
        

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: bool
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update
        side
            Which orderbook was updated
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")
        if ("A" or ticker=="B" or ticker=="C"):
            return
        test = []

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled
        side
            Side of order that was fulfilled
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
        if("A" or ticker=="B" or ticker=="C"):
            return
        test = []
 (pywrapper.cpp:50)
2023-11-17T22:45:42.381 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.381 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.405 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""
        place_market_order("BUY", "A", 1, 100)
        place_market_order("SELL", "A", 1, 105)


    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:42.406 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.406 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.454 -0600 [            ] [py_runtime] INFO     - Running code:
from collections import deque
import random

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY"""

# order
class Order:
    def __init__(self, ticker: str, side: str, price: float, quantity: float):
        self.ticker = ticker.upper()
        self.side = side.upper()
        self.price = price
        self.quantity = quantity

    """
    def print(self):
        print(self.ticker, self.side, "@" + str(self.price), self.quantity)
    """

    def getInfo(self) ->str :
        info = self.ticker + ", " + self.side + ", @" + str(self.price) + ", " + str(self.quantity)
        return info

# This is the order book
class OrderBook:
    def __init__(self):
        self.buyOrderDict = dict()
        self.sellOrderDict = dict()

    # add orders (BUY/SELL), called when on_orderbook_update is called
    def addOrder(self, order: Order):
        if order.side == "BUY":
            if order.ticker in self.buyOrderDict:
                if len(self.buyOrderDict[order.ticker]) > 1000:
                    self.buyOrderDict[order.ticker].popleft()
                self.buyOrderDict[order.ticker].append(order)
            else:
                alist = deque()
                alist.append(order)
                self.buyOrderDict[order.ticker] = alist
        elif order.side == "SELL":
            if order.ticker in self.sellOrderDict:
                if len(self.sellOrderDict[order.ticker]) > 1000:
                    self.sellOrderDict[order.ticker].popleft()
                self.sellOrderDict[order.ticker].append(order)
            else:
                alist = deque()
                alist.append(order)
                self.sellOrderDict[order.ticker] = alist

    def getCurrentBuyOrder(self, ticker: str) -> Order:
        symbol = ticker.upper()
        if symbol in self.buyOrderDict:
            tot = len(self.buyOrderDict[symbol])
            if tot > 0:
                return self.buyOrderDict[symbol][tot - 1]
        # not found
        return None

    def getCurrentSellOrder(self, ticker: str) -> Order:
        symbol = ticker.upper()
        if symbol in self.sellOrderDict:
            tot = len(self.sellOrderDict[symbol])
            if tot > 0:
                return self.sellOrderDict[symbol][tot - 1]
            # not found
        return None

    """
    def dump(self):
        print(">>>order book:")
        if len(self.buyOrderDict) > 0:
            for key, value in self.buyOrderDict.items():
                for order in self.buyOrderDict[key]:
                    print("[buy order]", order.getInfo())
        if len(self.sellOrderDict) > 0:
            for key, value in self.sellOrderDict.items():
                for order in self.sellOrderDict[key]:
                    print("[sell order]", order.getInfo())
    """


# TradeBook: a dict of tickers, mapping to a deque of trades
class TradeBook:
    def __init__(self):
        # key: ticker, value: list of Order objects
        self.buyTradeDict = dict()
        self.sellTradeDict = dict()

    # add trades to the trade book (BUY/SELL trades). Called when on_trade_update() is called
    def addTrade(self, trade: Order):
        if trade.side == "BUY":
            if trade.ticker in self.buyTradeDict:
                # do not add more than 1000 entries for this ticker,
                if len(self.buyTradeDict[trade.ticker]) > 1000:
                    self.buyTradeDict[trade.ticker].popleft()
                self.buyTradeDict[trade.ticker].append(trade)
            else:
                # nothing added for this ticker, let's add it
                alist = deque()
                alist.append(trade)
                self.buyTradeDict[trade.ticker] = alist
        elif trade.side == 'SELL':
            if trade.ticker in self.sellTradeDict:
                # do not add more than 1000 entries for this ticker,
                if len(self.sellTradeDict[trade.ticker]) > 1000:
                    self.sellTradeDict[trade.ticker].popleft()
                self.sellTradeDict[trade.ticker].append(trade)
            else:
                # nothing added for this ticker, let's add it
                alist = deque()
                alist.append(trade)
                self.sellTradeDict[trade.ticker] = alist

    # returns a list of the latest trades (from latest to oldest), or empty list
    def getLatestBuyTrades(self, ticker: str, numOfTradesToGet: int) -> list:
        symbol = ticker.upper()
        latestBuyTrades = list()
        if symbol in self.buyTradeDict:
            tot = len(self.buyTradeDict[symbol])
            if tot >= numOfTradesToGet:
                getCount = 0
                for i in reversed(range(tot)):
                    latestBuyTrades.append(self.buyTradeDict[symbol][i])
                    getCount += 1
                    if getCount >= numOfTradesToGet:
                        break
        return latestBuyTrades

    def getLatestSellTrades(self, ticker: str, numOfTradesToGet: int) -> list:
        symbol = ticker.upper()
        latestSellTrades = list()
        if symbol in self.sellTradeDict:
            tot = len(self.sellTradeDict[symbol])
            if tot >= numOfTradesToGet:
                getCount = 0
                for i in reversed(range(tot)):
                    latestSellTrades.append(self.sellTradeDict[symbol][i])
                    getCount += 1
                    if getCount >= numOfTradesToGet:
                        break
        return latestSellTrades

    def numOfBuyTrades(self, ticker: str):
        symbol = ticker.upper()
        if symbol in self.buyTradeDict:
            return len(self.buyTradeDict[symbol])
        else:
            return 0

    """
    def dump(self):
        print("--->trade book:")
        if len(self.buyTradeDict) > 0:
            for key, value in self.buyTradeDict.items():
                for trade in self.buyTradeDict[key]: # from oldest to latest
                    print("[buy trade]", trade.getInfo())
        if len(self.sellTradeDict) > 0:
            for key, value in self.sellTradeDict.items():
                for trade in self.sellTradeDict[key]:
                    print("[sell trade]", trade.getInfo())
        print("<---ends trade book")
    """

class Position:
    def __init__(self):
        self.tickerDict = dict()

    def getPosition(self, ticker: str) -> float:
        tickerUpper = ticker.upper()
        qty = 0.0
        if tickerUpper in self.tickerDict:
            qty = self.tickerDict.get(tickerUpper)
        return qty

    def updateQuantity(self, ticker: str, side: str, quantity: float) -> None:
        tickerUpper = ticker.upper()
        if side.upper() == "BUY":
            if tickerUpper in self.tickerDict:
                self.tickerDict[tickerUpper] += quantity
            else:
                self.tickerDict[tickerUpper] = quantity
        elif side.upper() == "SELL":
            if tickerUpper in self.tickerDict:
                self.tickerDict[tickerUpper] -= quantity

    """
    def dump(self):
        for key, value in self.tickerDict:
            print("Position, ticker=", key, "qty=", value)
    """


class Strategy:
    def __init__(self) -> None:
        self.tradeBook = TradeBook()
        self.orderBook = OrderBook()
        self.previousShortAvg = 0.0
        self.currentBalance = 100000.00
        self.position = Position()

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        trade = Order(ticker, side, price, quantity)
        self.tradeBook.addTrade(trade)
        crossOver = self.isCrossOver(ticker)
        if crossOver == 1:
            buyPrice = self.getBuyPrice(ticker)
            if buyPrice > 0.0:
                buyQty = self.currentBalance * 0.1 / buyPrice
                # print("on_trade_update: isCrossOver=", crossOver, "placing market order: buyPrice=", buyPrice, "qty=", buyQty)
                # skip checking return code
                if buyQty >= 1.0:
                    place_market_order("BUY", ticker, buyQty // 1, buyPrice)
                    ###test
                    # cost = buyQty * buyPrice
                    # self.on_account_update(ticker, "BUY", buyPrice, buyQty // 1, self.currentBalance - cost)

        elif crossOver == 2:
            sellPrice = self.getSellPrice(ticker)
            if sellPrice > 0.0:
                sellQty = self.position.getPosition(ticker) / 4.0
                # print("on_trade_update: isCrossOver=", crossOver, ", placing market order: sellPrice=", sellPrice, "sellQty=", sellQty)
                if sellQty >= 1.0:
                    place_market_order("SELL", ticker, sellQty // 1, sellPrice)
                    ###test
                    # cost = sellQty * sellPrice
                    # self.on_account_update(ticker, "SELL", sellPrice, sellQty // 1, self.currentBalance - cost)

        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        order = Order(ticker, side, price, quantity)
        self.orderBook.addOrder(order)

        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
            self,
            ticker: str,
            side: str,
            price: float,
            quantity: float,
            capital_remaining: float,
    ) -> None:
        self.currentBalance = capital_remaining
        self.position.updateQuantity(ticker, side, quantity)

        print(f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}")

    # returns the current moving avg, returns 0.0 if not found
    def getMovingAvg(self, ticker: str, movingLen: int) -> float:
        tickerUpper = ticker.upper()

        latestBuyTrades = self.tradeBook.getLatestBuyTrades(tickerUpper, movingLen)
        totPrice = 0.0
        movingAvg = 0.0

        if latestBuyTrades is not None and len(latestBuyTrades) >= movingLen:
            for trade in latestBuyTrades:
                totPrice += trade.price
            movingAvg = totPrice / float(movingLen)
        return movingAvg

    # returns the previous moving avg, returns 0.0 if not found
    def getPrevMovingAvg(self, ticker: str, movingLen: int) -> float:
        tickerUpper = ticker.upper()
        latestBuyTrades = self.tradeBook.getLatestBuyTrades(tickerUpper, movingLen+1)

        numOfTrades = len(latestBuyTrades)
        if numOfTrades >= movingLen:
            latestBuyTrades.pop(0) #removes the first item

        totPrice = 0.0
        movingAvg = 0.0
        if latestBuyTrades is not None and len(latestBuyTrades) >= movingLen:
            for trade in latestBuyTrades:
                totPrice += trade.price
            movingAvg = totPrice / float(movingLen)
        return movingAvg

    # 0: no, 1 - up, 2 - down
    def isCrossOver(self, ticker: str) -> int:
        tickerUpper = ticker.upper()

        shortLen = 30
        longLen = 300
        previousShortAvg = self.getPrevMovingAvg(tickerUpper, shortLen)
        shortAvg = self.getMovingAvg(tickerUpper, shortLen)
        longAvg = self.getMovingAvg(tickerUpper, longLen)

        # print("+++isCrossOver, ", previousShortAvg, longAvg, shortAvg)
        if previousShortAvg < longAvg and shortAvg > longAvg:
            return 1 # up, buy signal
        elif previousShortAvg > longAvg and shortAvg < longAvg:
            return 2 # down, sell signal
        else:
            return 0 # no cross-over

    # if diff(current bid - latest filled bid) / latest filled bid < 15%, then get the current bid price
    # else return 0.0
    # this may return 0.0 if delta == 0
    def getBuyPrice(self, ticker: str):
        currentBuyOrder = self.orderBook.getCurrentBuyOrder(ticker)
        latestBuyTrades = self.tradeBook.getLatestBuyTrades(ticker, 1)
        buyPrice = 0.0
        if currentBuyOrder is not None and latestBuyTrades is not None:
            delta = currentBuyOrder.price - latestBuyTrades[0].price
            if delta >= 0 and (delta/latestBuyTrades[0].price < 0.15):
                buyPrice = currentBuyOrder.price
        return buyPrice

    # if diff(current ask - latest filled ask) / latest filled asj < 15%, then get the current ask price
    # else return 0.0
    def getSellPrice(self, ticker: str):
        currentSellOrder = self.orderBook.getCurrentSellOrder(ticker)
        latestSellTrades = self.tradeBook.getLatestSellTrades(ticker, 1)
        sellPrice = 0.0
        if currentSellOrder is not None and latestSellTrades is not None:
            delta = currentSellOrder.price - latestSellTrades[0].price
            if delta >= 0 and (delta/latestSellTrades[0].price < 0.15):
                sellPrice = currentSellOrder.price
        return sellPrice

    def getCurrentPosition(self, ticker: str):
        tickerUpper = ticker.upper()
        quantity = self.position.getPosition(ticker)
        return quantity


"""
# ------------------------------------------------------------------------------
# tests
def test():
    myStrategy = Strategy()
    tot = 30000
    for idx in range(tot):
        ticker = "symbol-" #+ str(idx)
        idNum = random.randint(1, 10)
        ticker += str(idNum)
        price = round(random.uniform(50, 55), 2)
        quantity = random.randint(100, 300)

        # add 10 buy/sell orders to the order book
        myStrategy.on_orderbook_update(ticker, "BUY", price, quantity)
        myStrategy.on_orderbook_update(ticker, "SELL", price, quantity)

        myStrategy.on_trade_update(ticker, "BUY", price, quantity)
        myStrategy.on_trade_update(ticker, "SELL", price, quantity)

    # add some more buy/sell trades to the order book
    ticker = "symbol-1"  # + str(idx)
    price = round(random.uniform(50, 55), 2)
    quantity = random.randint(100, 300)
    myStrategy.on_orderbook_update(ticker, "BUY", price, quantity)
    myStrategy.on_orderbook_update(ticker, "SELL", price, quantity)

    #myStrategy.tradeBook.dump()
    #myStrategy.orderBook.dump()

if __name__ == "__main__":
    # testCrossover()
    test()

# ------------------------------------------------------------------------------
# end of tests
""" (pywrapper.cpp:50)
2023-11-17T22:45:42.474 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.474 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.458 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

import asyncio

TICKERS = ["A", "B", "C"]

class Strategy:

    def __init__(self) -> None:
    
        self.lvl_1 = {
            "A" : 0,
            "B" : 0,
            "C" : 0,
            }
        self.lvl_2 = {
            "A" : 0,
            "B" : 0,
            "C" : 0,
            }
        self.lvl_3 = {
            "A" : 0,
            "B" : 0,
            "C" : 0,
            }
        self.orderbook = {}

        for stock in TICKERS:

            self.orderbook[stock] = {
                'Best Bid':{'Price':0,'Quantity':0},
                'Best Ask':{'Price':0, 'Quantity':0}
            }

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    async def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        
        if side == "BUY" and price > self.orderbook[ticker]["Best Bid"]["Price"]:
            self.orderbook[ticker]["Best Bid"]["Price"] = price
            self.orderbook[ticker]["Best Bid"]["Quantity"] = quantity

        if side == "SELL" and price < self.orderbook[ticker]["Best Ask"]["Price"]:
            self.orderbook[ticker]["Best Ask"]["Price"] = price
            self.orderbook[ticker]["Best Ask"]["Quantity"] = quantity

        while True:
            for stock in TICKERS:

                if ask_price != self.orderbook[stock]["Best Ask"]["Price"]:
                    ask_price = self.orderbook[stock]["Best Ask"]["Price"] - .01
                    if (ask_price - bid_price) > 0 :
                        place_market_order("SELL", stock, (5000/ask_price), ask_price)
                        if not place_market_order("SELL", stock, (5000/ask_price), ask_price):
                            await asyncio.sleep(60)
                            place_market_order("SELL", stock, (5000/ask_price), ask_price)

                if bid_price != self.orderbook[stock]["Best Bid"]["Price"]:
                    bid_price = self.orderbook[stock]["Best Bid"]["Price"] + .01
                    if (ask_price - bid_price) > 0 :
                        place_market_order("BUY", stock, (5000/bid_price), bid_price)
                        if not place_market_order("BUY", stock, (5000/bid_price), bid_price):
                            await asyncio.sleep(60)
                            place_market_order("SELL", stock, (5000/ask_price), ask_price)

                if (self.orderbook[stock]["Best Ask"]["Price"] == 0 or self.orderbook[stock]["Best Bid"]["Price"] == 0):
                    ask_price = 101
                    bid_price = 99

                    place_market_order("BUY", stock, (5000/bid_price), bid_price)
                    if not place_market_order("BUY", stock, (5000/bid_price), bid_price):
                        await asyncio.sleep(60)
                        place_market_order("BUY", stock, (5000/bid_price), bid_price)
                    place_market_order("SELL", stock, (5000/ask_price), ask_price)
                    if not place_market_order("SELL", stock, (5000/ask_price), ask_price):
                        await asyncio.sleep(60)
                        place_market_order("SELL", stock, (5000/ask_price), ask_price)

                if (bid_price - 0.02) > 0 and self.lvl_1[stock] < 30:
                    place_market_order("BUY", stock, (15 - self.lvl_1), (bid_price - 0.02))
                    if not place_market_order("BUY", stock, (15 - self.lvl_1), (bid_price - 0.02)):
                        await asyncio.sleep(60)
                        place_market_order("BUY", stock, (15 - self.lvl_1), (bid_price - 0.02))
                    place_market_order("SELL", stock, (15 - self.lvl_1), (ask_price + 0.02))
                    if not place_market_order("SELL", stock, (15 - self.lvl_1), (ask_price + 0.02)):
                        await asyncio.sleep(60)
                        place_market_order("SELL", stock, (15 - self.lvl_1), (ask_price + 0.02))
                    self.lvl_1[stock] = 30

                if (bid_price - 0.04) > 0 and self.lvl_2[stock] < 20:
                    place_market_order("BUY", stock, (10 - self.lvl_2), (bid_price - 0.04))
                    if not place_market_order("BUY", stock, (10 - self.lvl_2), (bid_price - 0.04)):
                        await asyncio.sleep(60)
                        place_market_order("BUY", stock, (10 - self.lvl_2), (bid_price - 0.04))
                    place_market_order("SELL", stock, (10 - self.lvl_2), (ask_price + 0.04))
                    if not place_market_order("BUY", stock, (10 - self.lvl_2), (bid_price - 0.04)):
                        await asyncio.sleep(60)
                        place_market_order("BUY", stock, (10 - self.lvl_2), (bid_price - 0.04))
                    self.lvl_2[stock] = 20

                if (bid_price - 0.06) > 0 and self.lvl_3[stock] < 10:
                    place_market_order("BUY", stock, (5 - self.lvl_3), (bid_price - 0.06))
                    if not place_market_order("BUY", stock, (5 - self.lvl_3), (bid_price - 0.06)):
                        await asyncio.sleep(60)
                        place_market_order("BUY", stock, (5 - self.lvl_3), (bid_price - 0.06))
                    place_market_order("SELL", stock, (5 - self.lvl_3), (ask_price + 0.06))
                    if not place_market_order("SELL", stock, (5 - self.lvl_3), (ask_price + 0.06)):
                        await asyncio.sleep(60)
                        place_market_order("SELL", stock, (5 - self.lvl_3), (ask_price + 0.06))
                    self.lvl_3[stock] = 10


    async def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        
        self.lvl_1[ticker] = self.lvl_1[ticker] - quantity/2
        self.lvl_2[ticker] = self.lvl_2[ticker] - quantity/3
        self.lvl_3[ticker] = self.lvl_3[ticker] - quantity/6
            
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        ) (pywrapper.cpp:50)
2023-11-17T22:45:42.478 -0600 [            ] [py_runtime] INFO     - Running code:
import numpy as np
import pandas as pd
from time import sleep

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""
    """current strat:
        get the long term average stock price
        get the short term average stock price
            -if short term < long term by a certain degree,
                -if not too much of stock purchased
                    -buy stock
            -if short term > long term by a certain degree, 
                -sell 90% of stock
        continue until no money ????
    """
    
    def __init__(self) -> None:
        """Your initialization code goes here."""
        
        self.currCapital = 100000 #starting capital
        self.smoother = 0.1 #smoothing factor for ema
        self.cols = ['Ticker', "Buy Price", "SMA", "EMA", "Number of Trades", "Number of Stocks"]
        self.dataFrame = pd.DataFrame(columns=self.cols)
        self.dataFrame.set_index('Ticker')
        self.dataFrame.astype({'Buy Price': 'float'})
        self.dataFrame.astype({'SMA': 'float'})
        self.dataFrame.astype({'EMA': 'float'})
        self.dataFrame.astype({'Number of Stocks': 'float'})
        self.dataFrame.astype({'Number of Trades': 'float'})

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        #adding to dataFrame to track info
        if ticker not in self.dataFrame.index:
            self.dataFrame.loc[ticker] = (ticker, 0, price, price, 1, 0)

        #recalculate information
        else:
            
            self.dataFrame.loc[ticker,"SMA"] = (self.dataFrame.loc[ticker,"SMA"] * self.dataFrame.loc[ticker,"Number of Trades"] + price) / (self.dataFrame.loc[ticker,"Number of Trades"] + 1)
            self.dataFrame.loc[ticker,"EMA"] = (price * self.smoother + (1-self.smoother)*self.dataFrame.loc[ticker,"EMA"])
            self.dataFrame.loc[ticker,"Number of Trades"] += 1
            
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        
        #adding to dataFrame to track info
        if ticker not in self.dataFrame.index:
            self.dataFrame.loc[ticker] = (ticker, 0, price, price, 0, 0)

        else:
            
            #buy if ema > sma (on the uptrend)
            if self.dataFrame.loc[ticker,"EMA"] > self.dataFrame.loc[ticker,"SMA"]:
                buyPrice = self.dataFrame.loc[ticker,"EMA"]
                if buyPrice > price:
                    buyPrice = price
                    
                potInvest = self.currCapital * .35 / buyPrice
                    
                if not place_market_order("BUY", ticker, buyPrice, potInvest):
                    sleep(2)
                    place_market_order("BUY", ticker, buyPrice, potInvest)
            
            #sell if sma > ema (down trending)
            if self.dataFrame.loc[ticker,"SMA"] > self.dataFrame.loc[ticker,"EMA"] and self.dataFrame.loc[ticker,"Number of Stocks"] > 0:
                
                toSell = self.dataFrame.loc[ticker,"Number of Stocks"] * .9
                if toSell > quantity:
                    toSell = quantity
                    
                sellPrice = self.dataFrame.loc[ticker,"SMA"]
                if price > sellPrice:
                    sellPrice = price
                if not place_market_order("SELL", ticker, sellPrice, toSell):
                    sleep(2)
                    place_market_order("SELL", ticker, sellPrice, toSell)
            
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        
        #match info
        if side == "BUY":
            self.dataFrame.loc[ticker,"Buy Price"] = price
            self.dataFrame.loc[ticker,"Number of Stocks"] += quantity
        else:
            self.dataFrame.loc[ticker,"Number of Stocks"] -= quantity
        self.currCapital = capital_remaining
        
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        ) (pywrapper.cpp:50)
2023-11-17T22:45:42.482 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.482 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.559 -0600 [            ] [py_runtime] INFO     - Running code:
import time
import numpy as np


def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """


class Strategy:

    def __init__(self) -> None:
        self.capital = 100000 
        self.rolling_window = 20
        self.num_std_dev = 2
        self.rsi_period = 14
        self.cooldown_period = 5
        self.prices = {'A': np.array([]), 'B': np.array([]), 'C': np.array([])}
        self.positions = {}
        self.cooldown = {'A': 0, 'B': 0, 'C': 0}

    def place_order_with_retry(self, side: str, ticker: str, quantity: float, price: float, max_retries: int = 3, delay: float = 0.5) -> bool:
   
        for attempt in range(max_retries):
            success = place_market_order(side, ticker, quantity, price)
            if success:
                return True
            time.sleep(delay)
        # print(f"Failed to place order after {max_retries} attempts.")
        return False


    def compute_bollinger_bands(self, prices: list) -> tuple:
        if len(prices) < self.rolling_window:
            return None, None, None

        prices_window = np.array(prices[-self.rolling_window:])
        sma = np.mean(prices_window)
        rolling_std = np.std(prices_window)
        upper_band = sma + (rolling_std * self.num_std_dev)
        lower_band = sma - (rolling_std * self.num_std_dev)

        return sma, upper_band, lower_band

    def compute_ema(self, prices, span):
        weights = np.exp(np.linspace(-1., 0., span))
        weights /= weights.sum()

        ema = np.convolve(prices, weights, mode='full')[:len(prices)]
        ema[:span] = ema[span]

        return ema

    def compute_macd(self, prices, short_window=12, long_window=26, signal_window=9) -> tuple:
        short_ema = self.compute_ema(prices, short_window)
        long_ema = self.compute_ema(prices, long_window)

        macd_line = short_ema - long_ema
        signal_line = self.compute_ema(macd_line, signal_window)

        return macd_line[-1], signal_line[-1]

    def compute_rsi(self, prices: list) -> float:
        prices = np.array(prices)
        delta = np.diff(prices)

        gain = np.where(delta > 0, delta, 0)
        loss = np.where(delta < 0, -delta, 0)

        avg_gain = np.mean(gain[-self.rsi_period:])
        avg_loss = np.mean(loss[-self.rsi_period:])

        rs = avg_gain / avg_loss if avg_loss != 0 else 0
        rsi = 100 - (100 / (1 + rs))

        return rsi

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """

        self.prices[ticker] = np.append(self.prices[ticker], price)

        while len(self.prices[ticker]) > self.rolling_window:
            self.prices[ticker] = np.delete(self.prices[ticker], 0)

        if self.cooldown[ticker] > 0:
            self.cooldown[ticker] -= 1
            return

        sma, upper_band, lower_band = self.compute_bollinger_bands(self.prices[ticker])
        rsi = self.compute_rsi(self.prices[ticker])
        macd_line, signal_line = self.compute_macd(self.prices[ticker])

        volatility = (upper_band - lower_band) / sma
        position_size = self.capital * 0.1 / price * (1 / (1 + volatility))
          
        if sma is not None:
            if price > upper_band and rsi > 70 and macd_line > signal_line:

                if ticker in self.positions and self.positions[ticker]['side'] == 'BUY':

                    if self.place_order_with_retry("SELL", ticker, position_size, price):
                        del self.positions[ticker]

                elif ticker not in self.positions:

                    if self.place_order_with_retry("SELL", ticker, position_size, price):
                        self.positions[ticker] = {'side': 'SELL', 'entry_price': price, 'quantity': position_size}

            elif price < lower_band and rsi < 30 and macd_line < signal_line:

                if ticker in self.positions and self.positions[ticker]['side'] == 'SELL':

                    if self.place_order_with_retry("BUY", ticker, position_size, price):
                        del self.positions[ticker]

                elif ticker not in self.positions:

                    if self.place_order_with_retry("BUY", ticker, position_size, price):
                        self.positions[ticker] = {'side': 'BUY', 'entry_price': price, 'quantity': position_size}


        self.cooldown[ticker] = self.cooldown_period


    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """

 
    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """

        self.capital = capital_remaining

        
        # print(f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}") (pywrapper.cpp:50)
2023-11-17T22:45:42.562 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.562 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.561 -0600 [            ] [py_runtime] INFO     - Running code:
from collections import defaultdict, deque
import statistics
import time

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class OrderBook:
    def __init__(self, rolling_window_size: int = 10):

        # Basic OB structures
        self.buy_order_prices = defaultdict(list)  
        self.buy_order_quantities = defaultdict(dict) 
        self.sell_order_prices = defaultdict(list)  
        self.sell_order_quantities = defaultdict(dict)  

        # Stat vars
        self.ROLLING_WINDOW_SIZE = rolling_window_size

        self.imbalances = {} 

        self.spread_history = deque(maxlen=self.ROLLING_WINDOW_SIZE)
        self.vwap_history = deque(maxlen=self.ROLLING_WINDOW_SIZE)
        self.depth_history = deque(maxlen=self.ROLLING_WINDOW_SIZE)

    # Basic OB dynamics +
    def add_order(self, ticker: str, price: float, quantity: float, order_type: str):
        if order_type == 'BUY':
            self._add_to_book(self.buy_order_prices[ticker], self.buy_order_quantities[ticker], price, quantity, reverse=True)
        else:
            self._add_to_book(self.sell_order_prices[ticker], self.sell_order_quantities[ticker], price, quantity)

        self.update_imbalance(ticker)

    def remove_order(self, ticker: str, price: float, quantity: float, order_type: str):
        if order_type == 'BUY':
            self._remove_from_book(self.buy_order_prices[ticker], self.buy_order_quantities[ticker], price, quantity)
        else:
            self._remove_from_book(self.sell_order_prices[ticker], self.sell_order_quantities[ticker], price, quantity)

        self.update_imbalance(ticker)

    def _add_to_book(self, price_list, quantity_dict, price, quantity, reverse=False):

        if price in quantity_dict:
            quantity_dict[price] += quantity
        else:
            quantity_dict[price] = quantity

            price_list.append(price)
            price_list.sort(reverse=reverse)

    def _remove_from_book(self, price_list, quantity_dict, price, quantity):
        if price in quantity_dict:
            quantity_dict[price] -= quantity
        
            if quantity_dict[price] <= 0:
                del quantity_dict[price]
                price_list.remove(price)
        else:
            return
        

    # Imbalance +
    def update_imbalance(self, ticker : str) -> None:
        
        buy_price = self.buy_order_prices[ticker][0] if self.buy_order_prices[ticker] else 0
        sell_price = self.sell_order_prices[ticker][0] if self.sell_order_prices[ticker] else 0
        

        num = self.buy_order_quantities[ticker].get(buy_price, 0) - self.sell_order_quantities[ticker].get(sell_price, 0)
        num2 = self.buy_order_quantities[ticker].get(buy_price, 0) + self.sell_order_quantities[ticker].get(sell_price, 0)

        if num2 != 0:  
            self.imbalances[ticker] = num/num2
        else:
            self.imbalances[ticker] = 0  

    def getImbalance(self, ticker: str) -> float:
        if ticker in self.imbalances:
            return self.imbalances[ticker]
        else:
            return 0.0

    # Rolling window +
    def update_history(self, metric_history, new_value):
        metric_history.append(new_value)
        
        if len(metric_history) > self.ROLLING_WINDOW_SIZE:
            metric_history.popleft()
        
    # Stats and volatility +
    def bid_ask_spread(self, ticker: str) -> float:
        if not self.buy_order_prices[ticker] or not self.sell_order_prices[ticker]:
            return 999999999 # perhaps handle this case better
        best_bid = self.buy_order_prices[ticker][0]
        best_ask = self.sell_order_prices[ticker][0]
        return best_ask - best_bid

    def vwap(self, ticker: str) -> float:
        total_buy_value = sum(price * quantity for price, quantity in self.buy_order_quantities[ticker].items())
        total_buy_volume = sum(self.buy_order_quantities[ticker].values())

        total_sell_value = sum(price * quantity for price, quantity in self.sell_order_quantities[ticker].items())
        total_sell_volume = sum(self.sell_order_quantities[ticker].values())

        total_value = total_buy_value + total_sell_value
        total_volume = total_buy_volume + total_sell_volume

        if total_volume == 0:  
            return 0

        return total_value / total_volume


    def depth(self, ticker: str, depth: int = 10) -> float:
        bid_depth = sum([self.buy_order_quantities[ticker].get(price, 0) for price in self.buy_order_prices[ticker][:depth]])
        ask_depth = sum([self.sell_order_quantities[ticker].get(price, 0) for price in self.sell_order_prices[ticker][:depth]])
        return bid_depth + ask_depth
    

    def calculate_volatility_score(self, ticker: str) -> float:
        spread = self.bid_ask_spread(ticker)
        self.update_history(self.spread_history, spread)
        
        vwap_val = self.vwap(ticker)
        self.update_history(self.vwap_history, vwap_val)
        
        depth_val = self.depth(ticker)
        self.update_history(self.depth_history, depth_val)

        if len(self.spread_history) < 2 or len(self.vwap_history) < 2 or len(self.depth_history) < 2:
            return 0
        
        spread_std = statistics.stdev(self.spread_history)
        if spread_std == 0:
            standardized_spread = 0
        else:
            standardized_spread = (spread - statistics.mean(self.spread_history)) / spread_std

        vwap_std = statistics.stdev(self.vwap_history)
        if vwap_std == 0:
            standardized_vwap = 0
        else:
            standardized_vwap = (vwap_val - statistics.mean(self.vwap_history)) / vwap_std

        depth_std = statistics.stdev(self.depth_history)
        if depth_std == 0:
            standardized_depth = 0
        else:
            standardized_depth = (depth_val - statistics.mean(self.depth_history)) / depth_std
        

        weight_spread = 0.4
        weight_vwap = 0.3
        weight_depth = 0.3

        volatility_score = (weight_spread * standardized_spread +
                            weight_vwap * standardized_vwap +
                            weight_depth * standardized_depth)

        return volatility_score

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""

        self.capital = 0
        self.book = OrderBook()
        self.portfolio = {}

        #CONSIDERATIONS: (UNPOPULATED ORDERBOOK, STARTING STRAT), DYNAMIC THRESHOLD, TESTING, TENSORFLOW?

        # Imbalance - order timing vars
        self.buyThreshold = 0.15
        self.sellThreshold = -0.1


        # Volatility - position sizing vars
        self.highVolatilityBuySellThreshold = 0.2
        self.highVolatilityThreshold = 2
        self.lowVolatilityThreshold = -1

        # Risk eval on pos vars
        self.baseOrderSizes = {}
        self.risk = 0.2

        # Stoploss vars
        self.stoploss = -0.03
        self.entryPrices = {}

        # Order failure handling vars
        self.maxRetries = 3
        self.retryDelay = 0.075

        time.sleep(3) # INITIAL STRAT
    
    # Portfolio tracker
    def update_portfolio(self, ticker: str, quantity: float, side: str) -> None:
        if ticker not in self.portfolio:
            self.portfolio[ticker] = 0.0

        if side == "BUY":
            self.portfolio[ticker] += quantity
        elif side == "SELL":
            self.portfolio[ticker] -= quantity


    # Order size
    def update_base_order_size(self, ticker: str) -> None:
        if ticker not in self.baseOrderSizes:
            self.baseOrderSizes[ticker] = 0.0

        if self.book.sell_order_prices[ticker]:
            price = self.book.sell_order_prices[ticker][0]
        else:
            price = 0

        riskableCapital = self.capital * self.risk
        
        if price != 0:
            self.baseOrderSizes[ticker] = riskableCapital/price
        else:
            self.baseOrderSizes[ticker] = 0

    # Stoploss
    def evaluate_stop_loss(self, ticker: str, current_price: float) -> None:
        if ticker in self.entryPrices:
            if self.entryPrices[ticker] != 0:
                loss = (self.entryPrices[ticker] - current_price) / self.entryPrices[ticker]
            else:
                return
            if loss <= self.stoploss:
                order_size = self.portfolio.get(ticker, 0)  
                if order_size > 0:
                    self.safe_place_market_order("SELL", ticker, order_size, current_price)
                    del self.entryPrices[ticker]  


    # Safe MO placement and Further fallback strats
    def fallback_limit_order(self, side, ticker, quantity, price):
        adjustment = 0.01  
        limit_price = price + adjustment if side == "BUY" else price - adjustment
        return self.safe_place_market_order(side, ticker, quantity, limit_price)
    def fallback_reduce_size(self, side, ticker, quantity, price):
        reduced_size = quantity * 0.75  
        return self.safe_place_market_order(side, ticker, reduced_size, price)

    def safe_place_market_order(self, side: str, ticker: str, quantity: float, price: float) -> bool:
        retries = 0
        while retries < self.maxRetries:
            if place_market_order(side, ticker, quantity, price):
                return True
            
            if retries == self.maxRetries - 1:

                if self.fallback_reduce_size(side, ticker, quantity, price):
                    return True
                
                if self.fallback_limit_order(side, ticker, quantity, price):
                    return True
                
            retries += 1
            time.sleep(self.retryDelay)
        return False

    def trade(self, ticker) -> None:
        self.update_base_order_size(ticker)
        baseSize = self.baseOrderSizes[ticker]

        # Determine order size based on volatility 
        imbalance = self.book.getImbalance(ticker)
        volatility_score = self.book.calculate_volatility_score(ticker)

        order_size = baseSize
        
        if volatility_score > self.highVolatilityThreshold:
            if abs(imbalance) < self.highVolatilityBuySellThreshold:
                return  
            order_size = baseSize * 0.5  
        elif volatility_score < self.lowVolatilityThreshold:
            order_size = baseSize * 2  
        else:
            order_size = baseSize

        # Determine whether to trade or not and trade details
        if imbalance > self.buyThreshold and self.book.sell_order_prices[ticker]:
            self.safe_place_market_order("BUY", ticker, order_size, self.book.sell_order_prices[ticker][0]) # Place BUY MO for 1 of A B or C]

        if ticker in self.portfolio and self.portfolio[ticker]>order_size and imbalance < self.sellThreshold and self.book.buy_order_prices[ticker]:
            self.safe_place_market_order("SELL", ticker, order_size, self.book.buy_order_prices[ticker][0]) # Place SELL MO for 1 of A B or C

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side2023-11-17T22:45:42.560 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self, tracker_A_value=0, tracker_B_value=0, tracker_C_value=0, A_price=0, B_price=0, C_price=0) -> None:
        self.tracker_A_value = tracker_A_value
        self.tracker_B_value = tracker_B_value
        self.tracker_C_value = tracker_C_value
        self.A_price = A_price
        self.B_price = B_price
        self.C_price = C_price

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        if ticker == "A":
            if price > self.A_price:
                self.A_price = price
                self.tracker_A_value += 1
            if price < self.A_price:
                self.A_price = price
                self.tracker_A_value += -1
            else:
                self.A_price = price
                self.tracker_A_value = 0
        
        if ticker == "B":
            if price > self.B_price:
                self.B_price = price
                self.tracker_B_value += 1
            if price < self.B_price:
                self.B_price = price
                self.tracker_B_value += -1
            else:
                self.B_price = price
                self.tracker_B_value = 0

        if ticker == "C":
            if price > self.C_price:
                self.C_price = price
                self.tracker_C_value += 1
            if price < self.C_price:
                self.C_price = price
                self.tracker_C_value += -1
            else:
                self.C_price = price
                self.tracker_C_value = 0

        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )

    def execute(self):
        if self.tracker_A_value >= 5:
            place_market_order("BUY", "A", 5, self.A_price)
        if self.tracker_A_value <= -5:
            place_market_order("SELL", "A", 5, self.A_price)
        if self.tracker_B_value >= 5:
            place_market_order("BUY", "B", 5, self.B_price)
        if self.tracker_B_value <= -5:
            place_market_order("SELL", "B", 5, self.B_price)
        if self.tracker_C_value >= 5:
            place_market_order("BUY", "C", 5, self.C_price)
        if self.tracker_C_value <= -5:
            place_market_order("SELL", "C", 5, self.C_price) (pywrapper.cpp:50)
2023-11-17T22:45:42.562 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.562 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
 of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """

        if side == "BUY":
            self.book.remove_order(ticker, price, quantity, "SELL")
        else:
            self.book.remove_order(ticker, price, quantity, "BUY")
        self.evaluate_stop_loss(ticker, price)
        self.trade(ticker)

        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        
        self.book.add_order(ticker, price, quantity, side)
        self.evaluate_stop_loss(ticker, price)
        self.trade(ticker)

        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        
        if side == "BUY":
            self.entryPrices[ticker] = price

        self.capital = capital_remaining
        self.update_portfolio(ticker, quantity, side)

        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:42.558 -0600 [            ] [py_runtime] INFO     - Running code:
import numpy as np
import time

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:


    def __init__(self) -> None:
        self.prices = []
        self.upper_band = None
        self.lower_band = None

    def calculate_bollinger_bands(self):
        if len(self.prices) >= 20:
            sma = np.mean(self.prices[-20:])
            std_dev = np.std(self.prices[-20:])
            self.upper_band = sma + 2 * std_dev
            self.lower_band = sma - 2 * std_dev

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        self.prices.append(price)
        self.calculate_bollinger_bands()
        self.trade_decision(ticker, side, price, quantity)
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def trade_decision(self, ticker: str, side: str, current_price: float, quantity: float) -> None:
        if self.upper_band is not None and self.lower_band is not None:
            if current_price <= self.lower_band:
                order_placed = place_market_order("BUY", ticker, 1, current_price)
                if not order_placed:
                    time.sleep(2)
            elif current_price >= self.upper_band:
                order_placed = place_market_order("SELL", ticker, 1, current_price)
                if not order_placed:
                    time.sleep(2)
    
    def on_orderbook_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(self, ticker: str, side: str, price: float, quantity: float, capital_remaining: float) -> None:
        print(f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}") (pywrapper.cpp:50)
2023-11-17T22:45:42.560 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.560 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.587 -0600 [            ] [py_runtime] INFO     - Running code:
import time
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""
    
    currentBalance = 100000
    currentHoldings = {}
    
    def __init__(self) -> None:
        """Your initialization code goes here."""
        
    # Function for handling rate limiting and managing current holdings
    def make_trade(self, side: str, ticker: str, quantity: float, price: float):
        if(side=="BUY"):
            
            while(quantity*price>self.currentBalance):
                if(quantity<1):
                    return
                quantity/=2
                
        while True:
            try:
                place_market_order(side, ticker, quantity, price)
                print(f"Making {side} order at ${price} for {quantity} shares")

                break
            except Exception:
                time.sleep(3)

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        trade_quantity = 10
        spread = 0.1  
        
        # Buy order below the current order book price
        buy_order_price = price - spread
        self.make_trade("BUY",ticker,trade_quantity,buy_order_price)
        # Sell order above the current order book price
        sell_order_price = price + spread

        if(ticker in self.currentHoldings and self.currentHoldings[ticker]>=trade_quantity):
            self.make_trade("SELL",ticker,trade_quantity,sell_order_price)
        
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """

        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """

        self.currentBalance=capital_remaining
        if(side=="BUY"):
            self.currentHoldings[ticker]=quantity if ticker not in self.currentHoldings else self.currentHoldings[ticker]+quantity
        else:
            self.currentHoldings[ticker]-=quantity
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )

# strategy = Strategy()
# strategy.on_trade_update("A", "BUY", 100, 10)
# strategy.on_account_update("A","BUY",99.9,10,99001)
# strategy.on_trade_update("A", "SELL", 101, 10)
 (pywrapper.cpp:50)
2023-11-17T22:45:42.589 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.589 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.589 -0600 [            ] [py_runtime] INFO     - Running code:
import pandas as pd
from statistics import mean

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """


class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""

        # Current capital
        self.capital = 100000
        # Position tracker for A, B, and C
        self.position = pd.DataFrame(data = {"A":[0], "B":[0], "C":[0]})
        # Order tracker in format [Price, Quantity] for A, B, and C
        self.order = pd.DataFrame(data = {"A":[[]], "B":[[]], "C":[[]]})

        # Historical prices and averages
        self.history = pd.DataFrame(data = {"A":[[]], "B":[[]], "C":[[]]})
        self.MA = pd.DataFrame(data = {"n": [10, 30, 50, 100],
                                       "A":[None, None, None, None],
                                       "B":[None, None, None, None],
                                       "C":[None, None, None, None]})
        self.MA.set_index('n', inplace = True)

        # Signals to compare short and long moving averages.
        self.signal = pd.DataFrame(data = {"n": [30, 50, 100],
                                       "A":[None, None, None],
                                       "B":[None, None, None],
                                       "C":[None, None, None]})
        self.signal.set_index('n', inplace=True)
        self.prev_signal = pd.DataFrame(data={"n": [30, 50, 100],
                                         "A": [None, None, None],
                                         "B": [None, None, None],
                                         "C": [None, None, None]})
        self.prev_signal.set_index('n', inplace=True)

        # Sending extreme orders to exploit problematic algorithms
        place_market_order(side="BUY", ticker="A", quantity=100000, price=0.00001)
        place_market_order(side="BUY", ticker="B", quantity=100000, price=0.00001)
        place_market_order(side="BUY", ticker="C", quantity=100000, price=0.00001)
        place_market_order(side="SELL", ticker="A", quantity=100000, price=10000000)
        place_market_order(side="SELL", ticker="B", quantity=100000, price=10000000)
        place_market_order(side="SELL", ticker="C", quantity=100000, price=10000000)

    # Update position for each ticker
    def update_position(self, ticker, side, quantity):
        if side == "SELL":
            quantity = -quantity
        self.position[ticker].iloc[0] = self.position[ticker].iloc[0] + quantity

    # Open a new order in record
    def open_order(self, ticker, side, price, quantity):
        success = place_market_order(side, ticker, quantity, price)
        if side == "SELL":
            quantity = -quantity
        self.order[ticker].iloc[0].append([price, quantity])
        return success

    # Modify an existing order when fully or partially fulfilled
    def update_order(self, ticker, side, price, quantity):
        self.update_position(ticker, side, quantity)
        found = False
        if side == "SELL":
            quantity = -quantity
            max = 0
            for i in range (len(self.order[ticker].iloc[0])):
                if price > self.order[ticker].iloc[0][i][0] > max:
                    max = self.order[ticker].iloc[0][i][0]
                    idx = i
                    found = True
        else:
            min = 100000000
            for i in range (len(self.order[ticker].iloc[0])):
                if self.order[ticker].iloc[0][i][0] > price and self.order[ticker].iloc[0][i][0] < min:
                    min = self.order[ticker].iloc[0][i][0]
                    idx = i
                    found = True
        if found:
            # An existing order is found, modify the remaining quantity.
            # If the remaining quantity is 0, remove it.
            if quantity == self.order[ticker].iloc[0][idx][1]:
                del self.order[ticker].iloc[0][idx]
            else:
                self.order[ticker].iloc[0][idx][1] = self.order[ticker].iloc[0][idx][1] - quantity

    # Calculate moving average of n prices
    def calculate_MA(self, ticker):
        length = len(self.history[ticker].iloc[0])
        for n in [10, 30, 50, 100]:
            if length >= n:
                self.MA[ticker].loc[n] = mean(self.history[ticker].iloc[0][-n:])

        for n in [30, 50, 100]:
            if self.MA[ticker].loc[n] is not None:
                self.prev_signal[ticker].loc[n] = self.signal[ticker].loc[n]
                if self.MA[ticker].loc[n] > self.MA[ticker].loc[10]:
                    self.signal[ticker].loc[n] = -1
                else:
                    self.signal[ticker].loc[n] = 1

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")
        # Update moving average
        self.calculate_MA(ticker)

        # Examine trading criteria
        for n in [30, 50, 100]:
            if self.signal[ticker].loc[n] is not None and self.prev_signal[ticker].loc[n] is not None:
                if self.signal[ticker].loc[n] > self.prev_signal[ticker].loc[n]:
                    # Short MA up-cross long MA, BUY
                    # The quantity is given in a basis of current capital.
                    # The longer MA that MA_10 has crossed, the more to purchase as it indicates a
                    # higher likelihood of bullish. Vice versa for the SELL cass.
                    self.open_order(ticker, "BUY", price, n / 200 * self.capital / price)
                elif self.signal[ticker].loc[n] < self.prev_signal[ticker].loc[n]: \
                    self.open_order(ticker, "SELL", price, n / 200 * self.capital / price)

        # Ideally, cancel previous orders as new orders are placed.
        # This can be done using the position/order tracker and the update_order function which are done already.
        # However, since the order doesn't have a tag (primary key) and no cancel_order function is given,
        # it cannot be implemented.

    def on_orderbook_update(
            self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
            self,
            ticker: str,
            side: str,
            price: float,
            quantity: float,
            capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )

        self.capital = capital_remaining
        self.update_order(ticker, side, price, quantity)
 (pywrapper.cpp:50)
2023-11-17T22:45:42.593 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.593 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.611 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.611 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.618 -0600 [            ] [py_runtime] INFO     - Running code:
import time
import pandas as pd

def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

def try_place_order(side, ticker, quantity, price, retries=2, delay=2):
    for i in range(retries):
        success = place_market_order(side, ticker, quantity, price)
        if success:
            return True
        time.sleep(delay)
    return False


class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""
        self.prices = {}
        self.macd = {}
        self.signal = {}
        self.rsi = {}
        self.portfolio = {
            'capital': 100000,
            'stocks': {}
        }


    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")


    def handle_orderbook_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        # Store prices
        if ticker not in self.prices:
            self.prices[ticker] = []
        self.prices[ticker].append(price)

        # MACD and Signal line
        short_window = 5
        long_window = 15
        signal_window = 4

        data = pd.Series(self.prices[ticker])
        short_ema = data.ewm(span=short_window, adjust=False).mean()
        long_ema = data.ewm(span=long_window, adjust=False).mean()

        self.macd[ticker] = short_ema - long_ema
        self.signal[ticker] = self.macd[ticker].ewm(span=signal_window, adjust=False).mean()

        # RSI
        delta = data.diff()
        gain = (delta.where(delta > 0, 0)).fillna(0)
        loss = (-delta.where(delta < 0, 0)).fillna(0)

        avg_gain = gain.rolling(window=14).mean()
        avg_loss = loss.rolling(window=14).mean()

        rs = avg_gain / avg_loss
        self.rsi[ticker] = 100 - (100 / (1 + rs))

        # Trading strategy
        if len(self.prices[ticker]) > long_window:
            # Buy Condition:
            BUY_FRACTION_OF_CAPITAL = 0.07
            SELL_FRACTION_OF_OWNED = 0.33
            if self.macd[ticker].iloc[-1] > self.signal[ticker].iloc[-1] and self.rsi[ticker].iloc[-1] < 30:
                max_affordable_quantity = (self.portfolio.get('capital', 100000) * BUY_FRACTION_OF_CAPITAL) // price
                trade_quantity = min(quantity, max_affordable_quantity)
                if trade_quantity > 0:
                    if try_place_order("BUY", ticker, trade_quantity, price):
                        self.portfolio['capital'] -= price * trade_quantity
                        self.portfolio['stocks'][ticker] = self.portfolio['stocks'].get(ticker, 0) + trade_quantity

            # Sell Condition:
            elif self.macd[ticker].iloc[-1] < self.signal[ticker].iloc[-1] and self.rsi[ticker].iloc[-1] > 70:
                owned_quantity = self.portfolio['stocks'].get(ticker, 0)
                sellable_quantity = int(owned_quantity * SELL_FRACTION_OF_OWNED)
                trade_quantity = min(quantity, sellable_quantity)
                if trade_quantity > 0:
                    if try_place_order("SELL", ticker, trade_quantity, price):
                        self.portfolio['capital'] += price * trade_quantity
                        self.portfolio['stocks'][ticker] -= trade_quantity
                        if self.portfolio['stocks'][ticker] == 0:
                            del self.portfolio['stocks'][ticker]

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        self.handle_orderbook_update(ticker, side, price, quantity)
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Amount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        ) (pywrapper.cpp:50)
2023-11-17T22:45:42.626 -0600 [            ] [py_runtime] INFO     - Running code:
from collections import deque

class Strategy:
    def __init__(self) -> None:
        # Initial capital and starting stocks
        self.capital = 100000
        self.stocks = {'A': 0, 'B': 0, 'C': 0}
        
        # Store recent trade prices for moving average calculation
        self.recent_trade_prices = {'A': deque(maxlen=10), 'B': deque(maxlen=10), 'C': deque(maxlen=10)}
        
        # Rate limiting
        self.order_allowed = True
        self.order_fail_count = 0

    def average_price(self, ticker: str) -> float:
        """Calculate the average of recent trade prices."""
        if not self.recent_trade_prices[ticker]:
            return 0
        return sum(self.recent_trade_prices[ticker]) / len(self.recent_trade_prices[ticker])

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        # Store the trade price for average calculations
        self.recent_trade_prices[ticker].append(price)

    def on_orderbook_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        avg_price = self.average_price(ticker)
        
        # Buy logic: If the SELL price is 5% below the recent average and we have capital
        if side == "SELL" and price <= 0.95 * avg_price and self.capital >= price * quantity:
            if self.order_allowed:
                success = place_market_order("BUY", ticker, quantity, price)
                if not success:
                    self.order_allowed = False
                    self.order_fail_count += 1
        
        # Sell logic: If we have the stock and the BUY price is 5% above the recent average
        elif side == "BUY" and price >= 1.05 * avg_price and self.stocks[ticker] > 0:
            if self.order_allowed:
                success = place_market_order("SELL", ticker, quantity, price)
                if not success:
                    self.order_allowed = False
                    self.order_fail_count += 1

    def on_account_update(self, ticker: str, side: str, price: float, quantity: float, capital_remaining: float) -> None:
        # Update capital and stock counts
        self.capital = capital_remaining
        
        if side == "BUY":
            self.stocks[ticker] += quantity
        elif side == "SELL":
            self.stocks[ticker] -= quantity
        
        # Handle rate limiting - if we fail 3 times, wait for some time (not implemented here, but could be added)
        if not self.order_allowed and self.order_fail_count >= 3:
            # Reset after waiting (e.g., by using time.sleep() in a real-world scenario)
            self.order_allowed = True
            self.order_fail_count = 0

 (pywrapper.cpp:50)
2023-11-17T22:45:42.620 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.620 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.627 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.627 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.625 -0600 [            ] [py_runtime] INFO     - Running code:
# Global function:
# place_market_order(side, type, ticker, quantity, price)
# Where side = "BUY" or "SELL", type = "MARKET", ticker = "HIGH_VOL", "MED_VOL", or "LOW_VOL", quantity = float, price = float
class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""

    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched
        side

        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: bool
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update
        side
            Which orderbook was updated
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled
        side
            Side of order that was fulfilled
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
        this is a syntax error
 (pywrapper.cpp:50)
2023-11-17T22:45:42.626 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.626 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.624 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""
    

    def __init__(self) -> None:
        """Your initialization code goes here."""
        money=100000


    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
            
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        
            
            
        
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:42.626 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.626 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.718 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.718 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.731 -0600 [            ] [py_runtime] INFO     - Running code:
def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        
        place_market_order("BUY", "A", 100, 1)
        place_market_order("SELL" ,"A", 10, 2)
        self.on_trade_update("A", "SELL", 2, 10)

        
    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        print(
            f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}"
        )
 (pywrapper.cpp:50)
2023-11-17T22:45:42.731 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.731 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.748 -0600 [            ] [py_runtime] INFO     - Running code:

from queue import PriorityQueue
import numpy as np
import time



def place_market_order(side: str, ticker: str, quantity: float, price: float) -> bool:
    """Place a market order - DO NOT MODIFY

    Parameters
    ----------
    side
        Side of order to place ("BUY" or "SELL")
    ticker
        Ticker of order to place ("A", "B", or "C")
    quantity
        Volume of order to place
    price
        Price of order to place

    Returns
    -------
    True if order succeeded, False if order failed due to rate limiting

    ((IMPORTANT))
    You should handle the case where the order fails due to rate limiting (maybe wait and try again?)
    """

class Strategy:
    """Template for a strategy."""

    def __init__(self) -> None:
        """Your initialization code goes here."""

        self.die = False
        self.moneyleft = 100000


        #LOLOLOL 
        place_market_order("BUY", "A", 100000, 1)
        place_market_order("BUY", "B", 100000, 1)
        place_market_order("BUY", "C", 100000, 1)

        place_market_order("SELL", "A", 1000000,1000)
        place_market_order("SELL", "B", 1000000,1000)
        place_market_order("SELL", "C", 1000000,1000)
        
        self.bob = { #ORDERBOOK OF BUYS    **********INPUT WITH NEGATIVE PRICE
            "A":PriorityQueue(),
            "B":PriorityQueue(),
            "C":PriorityQueue()
        }
        self.sob = { #ORDERBOOK OF SELLS
            "A":PriorityQueue(),
            "B":PriorityQueue(),
            "C":PriorityQueue()
        }
        self.trades = { #LIST OF TRADES 
            "A":[],
            "B":[],
            "C":[]
        }
        self.lastTurn = {
            "A":"NA",
            "B":"NA",
            "C":"NA"
        }

        self.tdcount = 0  #using trades to map out candlesticks instead of time
        self.tdframe = 5 #how many trades are in a tradeframe
        self.framecount = 0
        
        self.trends = {
            "A": {"open": [],
                "high" :[],
                "low" :[],
                "close" :[]},
            "B": {"open": [],
                "high" :[],
                "low" :[],
                "close" :[]},
            "C": {"open": [],
                "high" :[],
                "low" :[],
                "close" :[]}
        }
        
        self.lastslope = None
        self.held ={
            "A":0,
            "B":0,
            "C":0
        }
                

        


    def on_trade_update(self, ticker: str, side: str, price: float, quantity: float) -> None:
        """Called whenever two orders match. Could be one of your orders, or two other people's orders.
        
        

        Parameters
        ----------
        ticker
            Ticker of orders that were matched ("A", "B", or "C")
        side 
            Side of orders that were matched ("BUY" or "SELL")
        price
            Price that trade was executed at
        quantity
            Volume traded
        """
        

        self.trades[ticker].append((price, quantity)) #UPDATE TRADING BOOKS
        self.tdcount+=1
        if self.tdcount%self.tdframe == 0:
            open = None
            high = None
            low = None
            close = None
       

            for i in range(self.tdframe):
                current = self.trades[ticker][-1*self.tdframe+i][0]
                if i ==0:
                    open = current
                elif i == self.tdframe-1:
                    close = current
                
                if high == None or current>high:
                    high = current
                if low == None or current<low:
                    low = current
               
            self.framecount+=1
            self.trends[ticker]["open"].append(open)
            self.trends[ticker]["high"].append(high)
            self.trends[ticker]["low"].append(low)
            self.trends[ticker]["close"].append(close)
         



        if side == "BUY":
            
            if self.sob[ticker].empty() == True:
                print(f"Python Trade update: {ticker} {side} {price} {quantity}")
                return
            sellside = self.sob[ticker].get() 
            if(sellside[1]>quantity): ## IF THE FIRST LIMIT ORDER IS MORE THAN ENOUGH TO FULFILL
                self.sob[ticker].put((price, sellside[1]-quantity)) # TAKE OFF QUANTITY FROM 
            elif(sellside[1]<quantity): #IF WE'RE STILL MISSING SOME
                sellquantity= quantity-sellside[1] #GET LEFTOVER QUANTITY
                while(self.sob[ticker].empty() == False and sellquantity>0): #AS LONG AS WE NEED MORE
                    sellside = self.sob[ticker].get() #POP AND SHAVE OFF
                    sellquantity= sellquantity-sellside[1]
                if(sellquantity<0):#PUT BACK IN ANY LEFTOVERS FROM THE LAST POP
                    self.sob[ticker].put((price, -1*sellquantity))

        if side == "SELL": #DO THE SAME FOR SELL TRADES
            if self.bob[ticker].empty() == True:
                print(f"Python Trade update: {ticker} {side} {price} {quantity}")
                return
            buyside = -1*self.bob[ticker].get()
            if(buyside[1]>quantity):
                self.bob[ticker].put((-1*price,buyside[1]-quantity))
            elif(buyside[1]<quantity):
                buyquantity= quantity-side[1]
                while(self.bob[ticker].empty() == False and buyquantity>0):
                    buyside = self.bob[ticker].get()
                    buyquantity-=buyside[1]
                if(quantity<0):
                    self.bob[ticker].put((-1*price, -1*buyquantity)) 

        print(f"Python Trade update: {ticker} {side} {price} {quantity}")

    def on_orderbook_update(
        self, ticker: str, side: str, price: float, quantity: float
    ) -> None:
        """Called whenever the orderbook changes. This could be because of a trade, or because of a new order, or both.

        Parameters
        ----------
        ticker
            Ticker that has an orderbook update ("A", "B", or "C")
        side
            Which orderbook was updated ("BUY" or "SELL")
        price
            Price of orderbook that has an update
        quantity
            Volume placed into orderbook
        """
        
        if side == "BUY":    
            self.bob[ticker].put((-1*price, quantity))
        else:
            self.sob[ticker].put((price, quantity))
        
        slope = None
        if self.framecount>10:
            pricesh = self.trends[ticker]["high"][-11:-1]
            pricesl = self.trends[ticker]["low"][-11:-1]
            coeffh = np.polyfit(range(10),pricesh,1)
            coeffl = np.polyfit(range(10),pricesl,1)
            slope = (coeffh[0] +coeffl[0])/2
        else:
            print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")
            return
        
        if abs(slope)<.001:
            slope = 0

        if self.lastslope ==None:
            self.lastslope = int(np.sign(slope))
        else:
            if int(np.sign(slope)) != self.lastslope:
                self.lastslope = np.sign(slope)
                if int(np.sign(slope))==1:#IF WE ARE AT A LOW???
                    if self.bob[ticker].empty() == True:
                        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")
                        return
                    top = self.bob[ticker].get()
                    self.bob[ticker].put(top)
                    if 1.5*-1*top[0]*top[1] > self.moneyleft:
                        tobuy = int(self.moneyleft/(top[0]+.01))
                        buying = place_market_order("BUY", ticker,tobuy,-1*top[0]+.01)
                        if buying == False:
                            time.sleep(3)
                            place_market_order("BUY", ticker,tobuy,-1*top[0]+.01)
                    else:
                        buying = place_market_order("BUY", ticker, 1.5*top[1],-1*top[0]+.01)
                        if buying == False:
                            time.sleep(3)
                            place_market_order("BUY", ticker,tobuy,-1*top[0]+.01)
                    
                elif int(np.sign(slope))==-1:#ITS ROLLING DOWNHILL
                    if self.sob[ticker].empty() == True:
                        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")
                        return
                    top = self.sob[ticker].get()
                    self.sob[ticker].put(top)
                    if 1.5*top[1]> self.held[ticker]:
                        selling = place_market_order("SELL", ticker,self.held[ticker],top[0]-.01)
                        if selling == False:
                            time.sleep(3)
                            place_market_order("SELL", ticker,self.held[ticker],top[0]-.01)
                    else:
                        selling = place_market_order("SELL", ticker,1.5*top[1],top[0]-.01)
                        if selling == False:
                            time.sleep(3)
                            place_market_order("SELL", ticker,1.5*top[1],top[0]-.01)


        print(f"Python Orderbook update: {ticker} {side} {price} {quantity}")

    def on_account_update(
        self,
        ticker: str,
        side: str,
        price: float,
        quantity: float,
        capital_remaining: float,
    ) -> None:
        """Called whenever one of your orders is filled.

        Parameters
        ----------
        ticker
            Ticker of order that was fulfilled ("A", "B", or "C")
        side
            Side of order that was fulfilled ("BUY" or "SELL")
        price
            Price that order was fulfilled at
        quantity
            Volume of order that was fulfilled
        capital_remaining
            Ammount of capital after fulfilling order
        """
        if side == "BUY":
            self.held[ticker]+=quantity
        else:
            self.held[ticker]-=quantity

        self.moneyleft = capital_remaining

        print(f"Python Account update: {ticker} {side} {price} {quantity} {capital_remaining}")


 (pywrapper.cpp:50)
2023-11-17T22:45:42.757 -0600 [            ] [main    ] INFO     - Received signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:45:42.757 -0600 [            ] [main    ] CRITICAL - Terminated unexpectedly because of signal: Abort trap: 6 (QuillSignalHandler.cpp)
2023-11-17T22:46:41.153 -0600 [            ] [rabbitmq] INFO     - Caught SIGINT, closing connection (main.cpp:84)
